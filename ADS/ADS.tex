\documentclass[11pt]{article}

\usepackage{../util}

\title{Algorithms and Data Structures (WIP)}

\date{Autumn 2023}
\author{Based on the online MSc in Computer Science by the University of York\\ Notes taken by Nathan McKeown-Luckly (Discord Username: skeletman)} 


\makeindex[columns=2, title=Index, intoc]

\begin{document}
\maketitle
\tableofcontents
\pagebreak
\section{Software and the Java Programming language}
\subsection{Software and Code}
\begin{defi}[Computer Program]
    A \term{program} is a set of instructions to be given to a computer.
\end{defi}
\begin{defi}[Software]
    \term{Software} means a program or set of programs.
\end{defi}
\begin{defi}[Application Software]
    \term{Application software} or \textrm{applications} are software that is designed for the user to interact with the computer.
\end{defi}
\begin{egs}
    Word processor, image editor, computer game, spreadsheet.
\end{egs}
\begin{defi}[System Software]
    \term{System software} is software that provides a platoform for other software to function.
\end{defi}
\begin{egs}
    Operating system, network software, game engine, search engine, compiler.
\end{egs}
\begin{defi}[Embedded Software, Embedded System]
    \term{Embedded software} refers to software designed to control devices that are do not primarily function as computers. Such devices are known as \term{embedded systems}.
\end{defi}
\begin{egs}
    Microwave ovens, cars, modems, robots.
\end{egs}
A computer can only understand instructions given to it in binary, we call such instructions \term{machine code}. However, this is not very convenient for humans, so we instead write in a human-readable \term{programming language}, for example \term{Java}. The code we write in these are translated into machine code by a piece of software called a \term{compiler}, to be executed by the computer.
\begin{defi}[Program code/Source Code]
    Code as it was written by a human, often in a programming language easily readable to humans, is called \term{program code} or \term{source code}.
\end{defi}
\begin{defi}[Syntax]
    The rules that must be followed for a piece of code to be valid in a programming language is called \term{syntax}.
\end{defi}
\pagebreak
\subsection{The Java Programming Language}
Java is an \term{object oriented} programming language. 
\begin{defi}[Object Oriented Programming] \label{def:OOP}
    \term{Object oriented programming} or \term{OOP} is a programming paradigm based on the notion of objects. Objects may contain both data (fields, attributes or properties), and code (methods).
\end{defi}
\begin{eg}
    Suppose we wish to simulate a physical scenario, where a cube has some force applied to it. In such a physics simulation, a cube object may have a field \inline{mass}, and a method \inline{calculateAcceleration} which takes an input of a force, and uses the \inline{mass} field to calculate the acceleration that the cube would experience.
\end{eg}
There are other programming paradigms: languages such as Haskell use the functional programming paradigm, which differs greatly from object oriented programming.
\par Compilers for many programming languages, such as C, compile program code directly into machine code. In figure \ref{fig:typicalCompilePipeline} we see that this requires a different compiler for each type of machine for the program to be run on.
\begin{figure}[H]
    \centering
    \caption{A typical pipeline for code compilation}
    \label{fig:typicalCompilePipeline}
    \vspace{10pt}
    \begin{tikzpicture}[roundnode/.style={ellipse, text width=1.5cm, align=center, draw=green!60, fill=green!5, very thick, minimum size=7mm},squarednode/.style={rectangle, text width=2cm, align=center, draw=red!60, fill=white, very thick, minimum size=5mm},]
        \node[roundnode] (sc) {Source Code};
        \node[squarednode] (c2) [below=of sc] {Compiler \\ For PC};
        \node[squarednode] (c1) [left=of c2] {Compiler \\ For Apple};
        \node[squarednode] (c3) [right=of c2] {Compiler \\ For Unix};
        \node[roundnode] (mc1) [below=of c1] {Apple Machine Code};
        \node[roundnode] (mc2) [below=of c2] {PC \\ Machine Code};
        \node[roundnode] (mc3) [below=of c3] {UNIX Machine Code};
        \draw[->] (sc.south) -- (c1.north);
        \draw[->] (sc.south) -- (c2.north);
        \draw[->] (sc.south) -- (c3.north);
        \draw[->] (c1.south) -- (mc1.north);
        \draw[->] (c2.south) -- (mc2.north);
        \draw[->] (c3.south) -- (mc3.north);
    \end{tikzpicture}
\end{figure}
However, Java is \term{platform-independent}: a compiled Java program can run on any type of machine. This is because Java compiles to \term{Java byte code}, which then can be run by the \term{Java virtual machine} or \term{JVM}, which is a piece of software that runs on various types of machines to translate the Java byte code into machine code. There are versions of JVM for Windows, Mac, Unix, Linux, mobile phones, and even many embedded systems.
\begin{figure}[H]
    \centering
    \caption{The pipeline for Java code compilation}
    \label{fig:javaCompilePipeline}
    \vspace{10pt}
    \begin{tikzpicture}[roundnode/.style={ellipse, text width=1.5cm, align=center,  draw=green!60, fill=green!5, very thick, minimum size=7mm},squarednode/.style={rectangle, draw=red!60, fill=white, very thick, minimum size=5mm},]
        \node[roundnode] (sc) {Source Code};
        \node[squarednode] (c) [below=of sc] {Java Compiler};
        \node[roundnode] (jbc) [below=of c] {Java Byte Code};
        \node[squarednode] (jvm) [below=of jbc] {Java Virtual Machine (JVM)};
        \node[roundnode] (a) [below=of jvm] {Apple Machine Code};
        \node[roundnode] (pc) [left=of a] {PC \\ Machine Code};
        \node[roundnode] (unix) [right=of a] {UNIX Machine Code};
        \draw[->] (sc.south) -- (c.north);
        \draw[->] (c.south) -- (jbc.north);
        \draw[->] (jbc.south) -- (jvm.north);
        \draw[->] (jvm.south) -- (a.north);
        \draw[->] (jvm.south) -- (pc.north);
        \draw[->] (jvm.south) -- (unix.north);
    \end{tikzpicture}
\end{figure}
\begin{defi}[Libraries, Packages]
    \term{Libraries} and \term{packages} are pre-compiled Java modules for use in your own programs.
\end{defi}
The \term{Java Runtime Environment} or \term{JRE} is the JVM along with the Java libraries. The \term{Java Development Kit} or \term{JDK} consists of the JRE, the Java compiler, and some other tools for java development.
\pagebreak
\subsection{Command Line Interfaces (CLIs) and Integrated Development Environments (IDEs)}
Henceforth we assume that the JDK is properly installed. If we wish to compile Java code using the command line, it should be saved as a .java file. Then we use \inline{javac} to compile the program into a \inline{.class} file, which contains Java byte code. Then to launch this with the JVM, we run the \inline{java} command. For example, to compile a file called \inline{test.java}, we would navigate to its directory, and enter \inline{javac test.java}, and to launch the program we enter \inline{java test}. 

\par During development, instead of doing this every time we wish to test a program, programmers will often use an \term{Integrated Devevlopment Environment} or \term{IDE} to handle this. An IDE will often have many features designed for development, such as syntax highlighting, version management tools and debugging tools.

\subsection{User Interfaces}
\begin{defi}[User Interfaces]
    A \term{user interface} or \term{UI} is the part of a program that prompts the user for input and provides the program output. 
\end{defi}
 A \term{console application} is an application which uses a \term{text based user interface}. Alternatively, an application can use a \term{graphical user interface} or \term{GUI}, which allows for elements such a text boxes and buttons.

\subsection{"Hello World" Program}
Once a Java program is compiled, running the program will execute the \inline{main}method in the class of the .java file that was compiled. In listing \ref{lst:HelloWorld}, the \inline{main} method is executed and hence the words "Hello World" are printed to the console when the program is executed.
\begin{lstlisting}[caption=Hello World, label=lst:HelloWorld]
public class HelloWorld
{
    public static void main(String[] args)
    {
        System.out.println("Hello World");
    }
}
\end{lstlisting}
For more on methods, see section \ref{sec:methods}. For more on classes, see section \ref{sec:classesAndObjects}.

\pagebreak
\section{Variables}
\subsection{Primitive Types}
\begin{defi}[Data type]
    A \term{data type} is a collection of data values, or the representation of these values on a machine.
\end{defi} 
In the Java programming language, the \term{primitive types} or \term{scalar types} are a collection of basic types which take up a fixed amount of memory. The primitive types along with the data which they store are displayed in figure \ref{fig:primitives}.
\begin{figure}[H]
    \centering
    \caption{Primitive types in Java}
    \label{fig:primitives}
    \vspace{10pt}
    \begin{tabular}{|l|l|p{60mm}|}
        \hline
        Java type & Description of Data & Range of values
        \\ \hline \hline
        \inline!byte! & Integers & $-128$ to $127$ \\ \hline
        \inline!short! & Integers & $-32,768$ to $32,767$ \\ \hline
        \inline!int! & Integers & $-2,147,483,648$ to \newline $2,147,483,647$ \\ \hline
        \inline!long! & Integers & $-9,223,372,036,854,775,808$ to \newline $9,223,372,036,854,775,807$ \\ \hline
        \inline!float! & Real numbers & $\pm1.4\times10^{-45}$ to $\pm3.4\times10^{38}$ \\ \hline
        \inline!double! & Real numbers & $\pm4.9\times10^{-324}$ to $\pm1.8\times10^{308}$ \\ \hline
        \inline!char! & Characters & Unicode character set\\ \hline
        \inline!boolean! & True or false & True or false \\ \hline
    \end{tabular}
\end{figure}
\subsection{Declaring and assigning variables}
\begin{defi}[Variable and Declaration]
    When we create a named location in memory to store a value of a given type, we are \term{declaring} a \term{variable}. They are called variables as the content may vary during the runtime of the program.
\end{defi}
In Java, we declare variables by writing: \inline!dataType variableName!. For example, if we wanted to declare an integer variable named score, we'd write
\vspace{-15pt}
\begin{lstlisting}
int score;
\end{lstlisting}
\begin{defi}[Assigning variables]
    When we give a variable a value, this is called \term{assigning} the variable a value.
\end{defi}
In Java, we use the \inline!=! symbol to assign variables, for example
\vspace{-15pt}
\begin{lstlisting}
score = 10;
\end{lstlisting}
We can declare and assign in the same line of code:
\vspace{-15pt}
\begin{lstlisting}
int score = 10;
\end{lstlisting}
Variables can be declared as \term{constant} by being preceded by the keyword \inline!final!.
\vspace{-30pt}
\begin{lstlisting}
final double speedOfLight = 300000000;
\end{lstlisting}
\subsection{Arithmetic Operators}
Arithmetic operations take numeric values and output a numeric value of the same type. In Java, these can be done using the operators listed in figure \ref{fig:arithmeticOperations}.
\begin{figure}[H]
    \caption{Arithmetic operations in Java}
    \label{fig:arithmeticOperations}
    \centering
    \vspace{10pt}
    \begin{tabular}{|l|l|}
        \hline Operation & Java operator \\ \hline \hline
        Addition & \inline!+! \\ \hline
        Subtraction & \inline!-! \\ \hline
        Multiplication & \inline!*! \\ \hline
        Division & \inline!/! \\ \hline
        Remainder or Modulus & \inline!%! \\ \hline
    \end{tabular}
\end{figure}
\begin{defi}[Overloading]
    A method or operator is said to be \term{overloaded} if it has multiple definitions, which may depend on context such as the data type or number of inputs.
\end{defi}
\begin{eg}The arithmetic operations are overloaded so we can use them on all of the primitive numeric types. For example \inline!/! is defined for both \inline!int! and \inline!double!. In the \inline!int! case, it returns a rounded down value, whereas in the \inline!double! case it returns a precise (as possible given double precision) value: \inline!3 / 2! will have value \inline!1! of type \inline!int!, but \inline!3.0 / 2.0! will have value \inline!1.5! of type \inline!double!.
\end{eg}
\pagebreak
\subsection{Comparison Operators}
Comparison operations take numeric values and output a boolean value. In Java, these can be done using the operators listed in figure \ref{fig:comparisonOperations}.
\begin{figure}[H]
    \caption{Comparison operations in Java}
    \label{fig:comparisonOperations}
    \centering
    \vspace{10pt}
    \begin{tabular}{|l|l|}
        \hline Operation & Java operator \\ \hline \hline
        Equal to & \inline!==! \\ \hline
        Not equal to & \inline"!=" \\ \hline
        Less than & \inline!<! \\ \hline
        Greater than & \inline!>! \\ \hline
        Less than or equal to & \inline!<=! \\ \hline
        Greater than or equal to & \inline!>=! \\ \hline
    \end{tabular}
\end{figure}
\begin{note} The \inline!==! operator (and by extension \inline"!=") only compares the value for \emph{primitive types}. We will see later in section \ref{subsec:EqualityOperator} that for objects, \inline!==! is unsuitable for comparing values.
    
\end{note}
\subsection{Logical Operators}
Logical operations take boolean values and output a boolean value. These can be done using the operators listed in figure \ref{fig:logicalOperations}
\vspace{-15pt}
\begin{figure}[H]
    \caption{Logical operations in Java}
    \label{fig:logicalOperations}
    \centering
    \vspace{10pt}
    \begin{tabular}{|l|l|}
        \hline Operation & Java operator \\ \hline \hline
        Logical NOT & \inline"!" \\ \hline
        Logical OR & \inline!||! \\ \hline
        Logical AND & \inline!&&! \\ \hline
    \end{tabular}
\end{figure}

\pagebreak
\section{Program design}
\begin{defi}[Program Design and Implementation]
    \term{Program design} is working out how to go about developing software. \term{Implementation} is the process of developing the software.
\end{defi}
\subsection{Pseudocode}
\term{Pseudocode} refers to code written with very loose syntax, not bound by that of any specific language.
\begin{algorithm}
    \caption{An example of pseudocode to calculate a price after tax}
    \label{alg:pseudocodeExample1}
    \textbf{display} prompt for price\;
    price $\gets$ \textbf{user input}\;
    \textbf{display} prompt for tax percentage\;
    tax $\gets$ \textbf{user input}\;
    \textbf{return} price * (1 + tax/100)\;
\end{algorithm}
\begin{algorithm}
    \caption{An alternative way of writing the same algorithm as in algorithm \ref{alg:pseudocodeExample1}}
    DISPLAY prompt for price\;
    ENTER price\;
    DISPLAY prompt for tax percentage\;
    ENTER tax\;
    RETURN price * (1 + tax/100)\;
\end{algorithm}
\pagebreak


\section{Selection and Iteration}
\subsection{If Statements}
An \term{if statement} executes a piece of code conditional on a boolean condition. The Java syntax for an if statement is
\vspace{-20pt}
\begin{lstlisting}[style=basic]
if(condition)
{
    code-if-condition-true
}
\end{lstlisting}
\subsection{If-Else Statements}
An \term{if-else statement} executes a piece of code conditional on a boolean condition, and if not executes another piece of code. The Java syntax for an if-else statement is
\vspace{-20pt}
\begin{lstlisting}[style=basic]
if(condition)
{
    code-if-condition-true
}
else
{
    code-if-condition-false
}
\end{lstlisting}
\subsection{Switch Statements}
A \term{switch statement} is a switch between many pieces of code based on the value of a varaible. In Java, the syntax for a switch statement is
\vspace{-20pt}
\begin{lstlisting}[style=basic]
switch(variable)
{
    case value1: code
        break;
    ...
    case valueN: code
        break;
    default: code
        break;
}
\end{lstlisting}
\subsection{For Loops}
A \term{for loop} iterates a piece of code a fixed number of times, with a varying parameter. The Java syntax for a for loop is
\vspace{-20pt}
\begin{lstlisting}[style=basic]
for(initialisation; termination; increment)
{
    code
}
\end{lstlisting}
The code in the header behaves as follows
\begin{itemize}
    \item \inline!initialisation! runs once, at the beginning of the loop's execution
    \item \inline!termination! should be a boolean expression: when this evaluates to \inline!false! the loop will terminate.
    \item \inline!increment! runs after each iteration of the loop
\end{itemize}
\begin{eg} A typical use of a for loop would be to add all the integers between 0 and 10. This would be written as follows
\begin{lstlisting}[caption=A typical use of a for loop, label=lst:forLoopDemo]
int total = 0;
for(int i = 0; i <= 10; i++)
{
    total += i;
}
\end{lstlisting}
In listing \ref{lst:forLoopDemo} we initialise a new variable \inline!int i = 0!, and each iteration of the loop \inline!i++! is executed, incrementing \inline!i! by 1. The loop terminates when \inline!i <= 10! no longer holds.
\end{eg}
\begin{note}
    When a variable is declared in the initialisation of a for loop, its scope is within that for loop.
\end{note}

\subsection{While loops}
A \term{while loop} iterates a piece of code while a boolean condition is true. The Java syntax for a for loop is
\vspace{-20pt}
\begin{lstlisting}[style=basic]
while(condition)
{
    code
}
\end{lstlisting}
\subsection{Do-While loops}
A \term{do-while loop} executes a piece of code once, then iterates it while a boolean condition is true. The Java syntax for a for loop is
\vspace{-20pt}
\begin{lstlisting}[style=basic]
do
{
    code
} while (condition)
\end{lstlisting}

\subsection{Break statements}
While inside a loop, you can use a \term{break statement} to terminate iteration of the loop.
\begin{eg} If you wanted to terminate a for loop when its counter reaches 3, you could write the following
\vspace{-15pt}
\begin{lstlisting}
for(int i = 0; i < 100; i++){
    if (i == 3)
    {
        break;
    }
}
\end{lstlisting}
\end{eg}

\subsection{Continue statements}
While inside a loop, you can use a \term{continue statement} to skip to the next iteration of the loop.
\begin{eg} If you wanted to skip an iteration in a for loop when its counter reaches 3, you could write the following
\vspace{-15pt}
\begin{lstlisting}
for(int i = 0; i < 100; i++){
    if (i == 3)
    {
        continue;
    }
}
\end{lstlisting}
\end{eg}
\pagebreak
\section{Methods}
\label{sec:methods}
\subsection{Declaring, Defining and Calling Methods}
Methods are defined using the following syntax:
\vspace{-15pt}
\begin{lstlisting}[style=basic]
modifiers return-type method-name(parameters) 
{
    method-body
}
\end{lstlisting}
Convention is that a method name will have the first letter lowercase. The first line of the method declaration is called the \term{method header}.
\begin{eg} We could use a method to take an integer and return it multiplied by 2.
\begin{lstlisting}[caption=An example method, label=lst:multByTwo]
public static int multByTwo(int x)
{
    return x * 2;
}
\end{lstlisting}
In this example \inline!public! and \inline!static! are modifiers, \inline!int! is the return type, \inline!multByTwo! is the method name, \inline!int x! is the parameter, and \inline!return x * 2;! is the method body.
\end{eg}
\noindent Methods are called using the following syntax:
\vspace{-15pt}
\begin{lstlisting}[style=basic]
method-name(parameters) 
\end{lstlisting}
\begin{eg} If we wanted to use the method in listing \ref{lst:multByTwo} to multiply 5 by 2 and assign it to variable \inline!num!, we would write the following code.
\vspace{-15pt}
\begin{lstlisting}
int num = multByTwo(5);
\end{lstlisting}
Methods may affect the state of the program, so sometimes we don't need to put the output into a variable. We may use \inline!void! as the return type for such methods. Regardless, any method can also be run without assigning the return value to a variable. The following example would run the method multByTwo, but not put the return value in a variable.
\vspace{-15pt}
\begin{lstlisting}
multByTwo(5);
\end{lstlisting}
\end{eg}
\pagebreak
\subsection{Modifiers for Methods}
In a method header in Java, you can use \term{modifiers} to modify various behaviours of the method: one \term{access modifier} then potentially a combination of \term{non-access modifier}s. The access modifiers are as follows
\begin{itemize}
    \item default (if you don't specify a modifier) - The method is accessible only in the same package.
    \item public - The method is accessible in all classes.
    \item private - The method is only accessible in the declared class.
    \item protected - The method is accessible in the same package and subclasses.
\end{itemize}
The non-access modifiers are
\begin{itemize}
    \item final - The method cannot be overridden or modified.
    \item static - The method belongs to the class rather than objects of that class.
    \item abstract (can only be used in an abstract class) - The method has no method body, which must be supplied by any subclass.
    \item transient - Makes the method ignored when serialising the object containing it.
    \item synchronised - The method can be accessed only by a single thread at a time.
\end{itemize}
\pagebreak
\subsection{Method Overloading}
It is allowed in Java to give multiple methods the same name, as long as they accept a different set of parameters. This is called \term{overloading}. For example, the following is valid Java code.
\begin{lstlisting}
static int max(int firstIn, int secondIn)
{
    if(firstIn > secondIn)
    {
        return firstIn;
    }
    else
    {
        return secondIn;
    }
}

static int max(int firstIn, int secondIn, int thirdIn)
{
    return(max(firstIn, max(secondIn, thirdIn)))
}
\end{lstlisting}
\begin{defi}[Polymorphism]
    Methods and operators with the same name being allowed to perform different function is called \term{polymorphism}.
\end{defi}
\pagebreak
\section{Classes and Objects}
\label{sec:classesAndObjects}
In definition \ref{def:OOP}, we defined object oriented programming, and said, objects may contain both data (fields, attributes or properties), and code (methods). The idea is that a \term{class} is a blueprint for an \term{object}. 
\subsection{Class Declaration}
The syntax for class declaration is as follows:
\vspace{-15pt}
\begin{lstlisting}[style=basic]
modifiers class class-name
{
    class-body
}
\end{lstlisting}
Convention is that a class name will have the first letter capitalised.
\subsection{The Class Body}
The class body may consist of method and attribute declarations. You may also provide a special method called a \term{constructor}, which has the same name as the class, and the return type is not written. For example, if we were to run a physics simulation of an object with mass under a gravitational force, a class \inline!PhysicsBox! may be defined as follows
\begin{lstlisting}[caption=PhysicsBox, label=lst:PhysicsBox]
public class PhysicsBox
{
    private double mass;
    private static double gravity = 9.81;

    public PhysicsBox(double massIn){
        mass = massIn;
    }

    public static void setGravity(double gravityIn){
        gravity = gravityIn;
    }

    public double getGravityForce(){
        return mass * gravityConst;
    }   
}
\end{lstlisting}
Notice that we have declared the attributes as private, so the only way to access the attributes are through the class' methods. This kind of data protection is called \term{encapsulation}. \\ Also, we have \term{initialised} the \inline{gravity} attribute, which sets the value at the start of the lifetime of the \inline!PhysicsBox! class, or if it were not \inline!static!, at the start of the lifetime of each \inline!PhysicsBox! object. Java always initialises attributes to a given value, numerical primitives to 0, \inline!boolean! to \inline!false!, \inline!Object! to \inline!null!
\subsection{Instantiating an object}
Creating a new object is called \term{instantiation}. This is achieved in Java as follows
\vspace{-30pt}
\begin{lstlisting}[style=basic]
class-name object-name = new class-name(parameters)
\end{lstlisting}
For example, to create an object called \inline"box" of the \inline"PhysicsBox" class above, with mass 5.0, we would write
\vspace{-15pt}
\begin{lstlisting}
PhysicsBox box = new PhysicsBox(5.0)
\end{lstlisting}

\subsection{Accessing the Public Methods and Attributes of an Object or Class}
To access the public methods of an object we have instantiated, we use the \term{dot operator}.
\vspace{-22pt}
\begin{lstlisting}[style=basic]
object-name.method-name(parameters)
\end{lstlisting}
Similarly for attributes we use
\vspace{-22pt}
\begin{lstlisting}[style=basic]
object-name.attribute-name
\end{lstlisting}
For example, to get the force acting on our box
\vspace{-15pt}
\begin{lstlisting}
double force = box.getGravityForce();
\end{lstlisting}
If the \inline!static! modifier has been used in the definition, instead we need to refer to the class name rather than the object name, for example, to set the gravity constant to 1, we would write
\vspace{-15pt}
\begin{lstlisting}
PhysicsBox.setGravity(1.0);
\end{lstlisting}
\subsection{The "this" keyword}
The \index{this keyword} \inline!this! keyword refers to the object which owns a method or constructor. It is useful to distinguish between class attributes and parameters with the same name. 
\subsection{Modifiers for Classes}
When declaring an class, you can use \term{modifiers} to modify various behaviours of the class: one \term{access modifier} then potentially a combination of \term{non-access modifier}s. The access modifiers are as follows
\begin{itemize}
    \item default (if you don't specify a modifier) - The class is accessible only by classes in the same package.
    \item public - The class is accessible in any other class.
\end{itemize}
The non-access modifiers are
\begin{itemize}
    \item final - The class cannot be inherited by other classes.
    \item abstract - Objects of this class cannot be created.
\end{itemize}


\subsection{Modifiers for Attributes}
When declaring an attribute, you can use \term{modifiers} to modify various behaviours of the attribute: one \term{access modifier} then potentially a combination of \term{non-access modifier}s. The access modifiers are as follows
\begin{itemize}
    \item default (if you don't specify a modifier) - The attribute is accessible only in the same package.
    \item public - The attribute is accessible in all classes.
    \item private - The attribute is only accessible in the declared class.
    \item protected - The attribute is accessible in the same package and subclasses.
\end{itemize}
The non-access modifiers are
\begin{itemize}
    \item final - The attribute cannot be overridden or modified.
    \item static - The attribute belongs to the class rather than objects of that class.
    \item transient - Makes the attribute ignored when serialising the object containing it.
    \item synchronised - The attribute can be accessed only by a single thread at a time.
    \item volatile - The attribute is always read from main memory, not from a thread-local cache. In practice, this means any thread will be able to read the most recently updated value for this attribute.
\end{itemize}
\section{Assignment and Equality}
\subsection{The Assignment Operator (=)}
\index{= operator}\index{assignment operator}The \inline!=! operator assigns a value to a variable. For example, the following assigns the value 10 to \inline!x!.
\vspace{-15pt}
\begin{lstlisting}
int x = 10;
\end{lstlisting}
When dealing with objects instead of primitives, the value that is assigned is the memory address of the object on the right hand side.
\begin{eg} Suppose we have a class \inline!Rectangle!
\begin{lstlisting}[caption=Rectangle, label=lst:Rectangle]
public class Rectangle
{
    private double length;
    private double width;

    public Rectangle(double length, double width)
    {
        this.length = length;
        this.width = width;
    }

    public setLength(double length)
    {
        this.length = length;
    }

    public setWidth(double width)
    {
        this.width = width;
    }
    
    public double getArea()
    {
        return length*width;
    }
}
\end{lstlisting}
\pagebreak
The listing \ref{lst:assignmentOperatorObject}, line 1 creates a new \inline!Rectangle! in memory with length 1.0 and width 1.0, and assign \inline!rect! to its memory address.
\\ In line 2, \inline!rect2! would be assigned the value of \inline!rect!, i.e. the memory address of the rectangle.
\\ Then in line 3, we use the \inline!setWidth! method to set \inline!rect2.width! to 5.0. As \inline!rect2! points to the same object as \inline!rect!, this method sets \inline!rect.width! to 5.0.
\\ In line 4, we set \inline!area! to \inline!rect.getArea()!. This returns \inline!5.0!, as \inline!rect.length! is 1.0 and \inline!rect.width! is 5.0.
\begin{lstlisting}[caption=A sample of code to interact with the Rectangle class, label=lst:assignmentOperatorObject] 
Rectangle rect = new Rectangle(1.0,1.0);
Rectangle rect2 = rect;
rect2.setWidth(5.0);
double area = rect.getArea();
\end{lstlisting}
\end{eg}
\begin{defi}[Aliasing]
\term{Aliasing} is when an object is assigned multiple names. In listing \ref{lst:assignmentOperatorObject}, we see \inline!rect2! is an \term{alias} of \inline!rect!.
\end{defi}
\subsection{The new Keyword}
The \term{new keyword} creates a new object, at runtime it assigns an area in memory on the heap to store that object, and returns a reference to that object. It has one argument, being the constructor of the object to be initialised.

\subsection{The Equality Operator (==)} \label{subsec:EqualityOperator}
\index{== operator}\index{equality operator}The \inline!==! operator will tell you if two non-null references refer to the same object in memory. This is called \term{reference equality}. In practice, this means that when comparing objects using \inline!==!, you are comparing their memory address, not their data. \textbf{WARNING: It is a common mistake to use \inline!==! to compare the data contained by an object. You should instead use a method which compares the data you require to be compared (often the overridden \inline!equals! method).} With the following declarations, we would have that \inline!a==b! would return \inline!true!, but \inline!a==c! would return \inline!false!, despite \inline!a! and \inline!c! containing the same data!
\vspace{-15pt}
\begin{lstlisting}
String a = new String("str");
String b = a;
String c = new String("str");
\end{lstlisting}
In contrast, for primitives, the \inline!==! operator returns the \term{value equality}, i.e. true if and only if the variables contain the same value.
\section{Common Classes}
\subsection{Object}
Every class is a subclass of \inline!Object!, so inherits its methods. Examples of such methods are 
\begin{itemize}
    \item \inline!public boolean equals(Object obj)! - Returns true if the current object is equal to \inline!obj!. The equals method for the class \inline!Object! this is the same as the  \inline!==! operator. \textbf{WARNING: This means that two objects may be indistinguishable by the data and methods they hold, but are still distinguished by the equals method!} As a result, for most classes the equals method is overriden.
    \item \inline!protected Object clone()! - Produces a clone of the current object, such that \inline!x.clone() == x! will return false.
    \item \inline!public String toString()! - Returns a string representation of the object. Usually overridden to give more useful information.
\end{itemize}
\subsection{String}
A \term{string} is a sequence of characters. The \inline{String} class represents \term{immutable} strings, that is, they cannot be modified by methods.
\begin{defi}[String Literal]
    A \term{string literal} is a piece of code which represents a fixed string. 
\end{defi}
In Java, string literals are represented as a string within quotation marks, for example \inline!"This is a string literal"!. String literals are implemented as instances of the class \inline!String!. 
\par Use of the same string literal twice will reference to the same \inline!String! object in memory. For example, with the following declarations, \inline!a == b! would return \inline!true!.
\vspace{-15pt}
\begin{lstlisting}
String a = "str"
String b = "str"
\end{lstlisting}
The string class has many associated methods, such as:
\begin{itemize}
    \item \inline!public int length()! - Returns the length of the string.
    \item \inline!public boolean equals(Object obj)! - Returns true if and only if \inline!obj! is a \inline!String! object and has the same value as the current string. Overrides the \inline!equals! method for the \inline!Object! class.
    \item \inline!public String substring(int beginIndex, int endIndex)! - \newline Returns the substring of this string beginning with the \inline!beginIndex!$^{\text{th}}$ character, ending with the  \inline!(endIndex-1)!$^{\text{th}}$ character.
    \item \inline!public String toLowerCase()! - Returns the string in lowercase.
    \item \inline!public String toUpperCase()! - Returns the string in uppercase.
\end{itemize}
\subsection{Wrappers}
For each primitive data type, there is a \term{wrapper class} which hold a single field of the corresponding primitive type.
\begin{figure}[H]
    \caption{The wrapper classes}
    \label{fig:wrappers}
    \centering
    \vspace{10pt}
    \begin{tabular}{|l|l|}
    \hline
    Primitive Type & Wrapper Class \\ \hline \hline
    byte & Byte \\ \hline
    short & Short \\ \hline
    int & Integer \\ \hline
    long & Long \\ \hline
    float & Float \\ \hline
    double & Double \\ \hline
    boolean & Boolean \\ \hline
    char & Character \\ \hline
    \end{tabular}
\end{figure}
\term{Autoboxing} allows us to use primitive values in place of wrapper objects, and \term{unboxing} allows vice versa.
\subsection{Scanner}
The \term{Scanner class} allows text input to the program, with ability to parse primitive types, and use regular expressions to parse strings. Scanners can scan from user input to a console, from files, and from String objects. \par This class comes in a package called \inline!util!.  We use the \index{import keyword}\inline!import! keyword to import packages.
\vspace{-15pt}
\begin{lstlisting}
import java.util.Scanner;
\end{lstlisting}
or we can use an asterisk to import the whole package
\vspace{-15pt}
\begin{lstlisting}
import java.util.*;
\end{lstlisting}
\begin{lstlisting}[caption=Sample use of the Scanner class, label=lst:scannerExample]
Scanner sc = new Scanner(System.in);
int i = sc.nextInt();
long j = sc.nextLong();
String k = sc.next();
System.out.println(i + ", " + j + ", " + k);
sc.close();
\end{lstlisting}
In listing \ref{lst:scannerExample}, 3 user inputs are taken from the console, and they are outputted separated by commas.
\printindex
\end{document}