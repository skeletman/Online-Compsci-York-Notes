\documentclass[11pt]{report}

\usepackage{../util}

\title{Algorithms and Data Structures (WIP)}

\date{Autumn 2023}
\author{Based on the online MSc in Computer Science by the University of York\\ Notes taken by Nathan McKeown-Luckly (Discord Username: skeletman)} 


\makeindex[columns=2, title=Index, intoc]

\begin{document}
\maketitle
\tableofcontents
\pagebreak
\chapter{The Java Programming Language}
\section{Software and the Java Programming language}
\subsection{Software and Code}
\begin{defi}[Computer Program]
    A \term{program} is a set of instructions to be given to a computer.
\end{defi}
\begin{defi}[Software]
    \term{Software} means a program or set of programs.
\end{defi}
\begin{defi}[Application Software]
    \term{Application software} or \term{applications} are software that is designed for the user to interact with the computer.
\end{defi}
\begin{egs}
    Word processor, image editor, computer game, spreadsheet.
\end{egs}
\begin{defi}[System Software]
    \term{System software} is software that provides a platoform for other software to function.
\end{defi}
\begin{egs}
    Operating system, network software, game engine, search engine, compiler.
\end{egs}
\begin{defi}[Embedded Software, Embedded System]
    \term{Embedded software} refers to software designed to control devices that are do not primarily function as computers. Such devices are known as \term{embedded systems}.
\end{defi}
\begin{egs}
    Microwave ovens, cars, modems, robots.
\end{egs}
A computer can only understand instructions given to it in binary, we call such instructions \term{machine code}. However, this is not very convenient for humans, so we instead write in a human-readable \term{programming language}, for example \term{Java}. The code we write in these are translated into machine code by a piece of software called a \term{compiler}, to be executed by the computer.
\begin{defi}[Program code/Source Code]
    Code as it was written by a human, often in a programming language easily readable to humans, is called \term{program code} or \term{source code}.
\end{defi}
\begin{defi}[Syntax]
    The rules that must be followed for a piece of code to be valid in a programming language is called \term{syntax}.
\end{defi}
\noindent When code is written in this document, it will be presented in a box with line numbers on the left hand side. {\color{blue} Blue} font will be used for Java keywords, {\color{mymauve} purple} for string literals, and {\color{mygreen} green} for code comments. We see a sample of such a presentation in listing \ref{lst:sampleListing}.
\begin{lstlisting}[caption=A sample of code, label=lst:sampleListing]
/*
A sample of Java code.
*/
public class HelloWorld
{
    public void main(String[] args)
    {
        System.out.println("Hello World");
    }
} 
\end{lstlisting}
When defining pieces of syntax, I will use {\slshape\color{mygray} italic grey} font to represent fields where the programmer needs to choose the value. For example, we will see in section \ref{sec:forLoops}, the definition of a for loop will look as follows, to indicate that \inlineJava"!!!initialisation!!!", \inlineJava"!!!termination!!!", \inlineJava"!!!increment!!!" and \inlineJava"!!!code!!!" should be replaced to fit the programmer's needs
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
for(!!!initialisation!!!; !!!termination!!!; !!!increment!!!)
{
    !!!code!!!
}
\end{lstlisting}
\subsection{The Java Programming Language}
Java is an \term{object oriented} programming language. 
\begin{defi}[Object Oriented Programming] \label{def:OOP}
    \term{Object oriented programming} or \term{OOP} is a programming paradigm based on the notion of objects. Objects may contain both data (fields, attributes or properties), and code (methods).
\end{defi}
\begin{eg}
    Suppose we wish to simulate a physical scenario, where a cube has some force applied to it. In such a physics simulation, a cube object may have a field \inlineJava{mass}, and a method \inlineJava{calculateAcceleration} which takes an input of a force, and uses the \inlineJava{mass} field to calculate the acceleration that the cube would experience.
\end{eg}
There are other programming paradigms: languages such as Haskell use the functional programming paradigm, which differs greatly from object oriented programming.
\par Compilers for many programming languages, such as C, compile program code directly into machine code. In figure \ref{fig:typicalCompilePipeline} we see that this requires a different compiler for each type of machine for the program to be run on.
However, Java is \term{platform-independent}: a compiled Java program can run on any type of machine. This is because Java compiles to \term{Java byte code}, which then can be run by the \term{Java virtual machine} or \term{JVM}, a piece of software that runs on various types of machines to translate the Java byte code into machine code. There are versions of JVM for Windows, Mac, Unix, Linux, mobile phones, and even many embedded systems. For a diagram see figure \ref{fig:javaCompilePipeline}.
\begin{figure}[H]
    \centering
    \caption{A comparison between the compilation pipelines in other languages vs Java}
    \label{fig:compilePipelineComparison}
    \begin{subfigure}[t]{.5\textwidth}
        \centering
        \caption{A typical pipeline for compilation}
        \label{fig:typicalCompilePipeline}
        \vspace{10pt}
        \resizebox{0.9\textwidth}{!}{
        \begin{tikzpicture}[roundnode/.style={ellipse, text width=1.5cm, align=center, draw=green!60, fill=green!5, very thick, minimum size=7mm},squarednode/.style={rectangle, text width=2cm, align=center, draw=red!60, fill=white, very thick, minimum size=5mm},]
            \node[roundnode] (sc) {Source Code};
            \node[squarednode] (c2) [below=of sc] {Compiler \\ For PC};
            \node[squarednode] (c1) [left=of c2] {Compiler \\ For Apple};
            \node[squarednode] (c3) [right=of c2] {Compiler \\ For Unix};
            \node[roundnode] (mc1) [below=of c1] {Apple Machine Code};
            \node[roundnode] (mc2) [below=of c2] {PC \\ Machine Code};
            \node[roundnode] (mc3) [below=of c3] {UNIX Machine Code};
            \draw[->,line width = 1pt] (sc.south) -- (c1.north);
            \draw[->,line width = 1pt] (sc.south) -- (c2.north);
            \draw[->,line width = 1pt] (sc.south) -- (c3.north);
            \draw[->,line width = 1pt] (c1.south) -- (mc1.north);
            \draw[->,line width = 1pt] (c2.south) -- (mc2.north);
            \draw[->,line width = 1pt] (c3.south) -- (mc3.north);
        \end{tikzpicture}
        }
    \end{subfigure}%
    \begin{subfigure}[t]{.5\textwidth}
        \centering
        \caption{The pipeline for Java compilation}
        \label{fig:javaCompilePipeline}
        \vspace{10pt}
        \resizebox{0.9\textwidth}{!}{
        \begin{tikzpicture}[roundnode/.style={ellipse, text width=1.5cm, align=center,  draw=green!60, fill=green!5, very thick, minimum size=7mm},squarednode/.style={rectangle, draw=red!60, fill=white, very thick, minimum size=5mm},]
            \node[roundnode] (sc) {Source Code};
            \node[squarednode] (c) [below=of sc] {Java Compiler};
            \node[roundnode] (jbc) [below=of c] {Java Byte Code};
            \node[squarednode] (jvm) [below=of jbc] {Java Virtual Machine (JVM)};
            \node[roundnode] (a) [below=of jvm] {Apple Machine Code};
            \node[roundnode] (pc) [left=of a] {PC \\ Machine Code};
            \node[roundnode] (unix) [right=of a] {UNIX Machine Code};
            \draw[->,line width = 1pt] (sc.south) -- (c.north);
            \draw[->,line width = 1pt] (c.south) -- (jbc.north);
            \draw[->,line width = 1pt] (jbc.south) -- (jvm.north);
            \draw[->,line width = 1pt] (jvm.south) -- (a.north);
            \draw[->,line width = 1pt] (jvm.south) -- (pc.north);
            \draw[->,line width = 1pt] (jvm.south) -- (unix.north);
        \end{tikzpicture}
        }
    \end{subfigure}
\end{figure}

\begin{defi}[Libraries, Packages]
    \term{Libraries} and \term{packages} are pre-compiled Java modules for use in your own programs.
\end{defi}
The \term{Java Runtime Environment} or \term{JRE} is the JVM along with the Java libraries. The \term{Java Development Kit} or \term{JDK} consists of the JRE, the Java compiler, and some other tools for java development.

\subsection{Command Line Interfaces (CLIs) and Integrated Development Environments (IDEs)}
Henceforth we assume that the JDK is properly installed. If we wish to compile Java code using the command line, it should be saved as a .java file. Then we use \inlineJava{javac} to compile the program into a \inlineJava{.class} file, which contains Java byte code. Then to launch this with the JVM, we run the \inlineJava{java} command. For example, to compile a file called \inlineJava{test.java}, we would navigate to its directory, and enter \inlineJava{javac test.java}, and to launch the program we enter \inlineJava{java test}. 

\par During development, instead of doing this every time we wish to test a program, programmers will often use an \term{Integrated Devevlopment Environment} or \term{IDE} to handle this. An IDE will often have many features designed for development, such as syntax highlighting, version management tools and debugging tools.

\subsection{User Interfaces}
\begin{defi}[User Interfaces]
    A \term{user interface} or \term{UI} is the part of a program that prompts the user for input and provides the program output. 
\end{defi}
 A \term{console application} is an application which uses a \term{text based user interface}. Alternatively, an application can use a \term{graphical user interface} or \term{GUI}, which allows for elements such a text boxes and buttons.

\subsection{"Hello World" Program}
Once a Java program is compiled, running the program will execute the \inlineJava{main}method in the class of the .java file that was compiled. In listing \ref{lst:sampleListing}, the \inlineJava{main} method is executed and hence the words "Hello World" are printed to the console when the program is executed.
For more on methods, see section \ref{sec:methods}. For more on classes, see section \ref{sec:classesAndObjects}.

\pagebreak
\section{Variables}
\subsection{Primitive Types}
\begin{defi}[Data type]
    A \term{data type} is a collection of data values, or the representation of these values on a machine.
\end{defi} 
In the Java programming language, the \term{primitive types} or \term{scalar types} are a collection of basic types which take up a fixed amount of memory. The primitive types along with the data which they store are displayed in figure \ref{fig:primitives}.
\begin{figure}[H]
    \centering
    \caption{Primitive types in Java}
    \label{fig:primitives}
    \vspace{10pt}
    \begin{tabular}{|l|l|p{60mm}|}
        \hline
        Java type & Description of Data & Range of values
        \\ \hline \hline
        \inlineJava!byte! & Integers & $-128$ to $127$ \\ \hline
        \inlineJava!short! & Integers & $-32,768$ to $32,767$ \\ \hline
        \inlineJava!int! & Integers & $-2,147,483,648$ to \newline $2,147,483,647$ \\ \hline
        \inlineJava!long! & Integers & $-9,223,372,036,854,775,808$ to \newline $9,223,372,036,854,775,807$ \\ \hline
        \inlineJava!float! & Real numbers & $\pm1.4\times10^{-45}$ to $\pm3.4\times10^{38}$ \\ \hline
        \inlineJava!double! & Real numbers & $\pm4.9\times10^{-324}$ to $\pm1.8\times10^{308}$ \\ \hline
        \inlineJava!char! & Characters & Unicode character set\\ \hline
        \inlineJava!boolean! & True or false & True or false \\ \hline
    \end{tabular}
\end{figure}
\subsection{Declaring and assigning variables}
\begin{defi}[Variable and Declaration]
    When we create a named location in memory to store a value of a given type, we are \term{declaring} a \term{variable}. They are called variables as the content may vary during the runtime of the program.
\end{defi}
In Java, we declare variables by writing: \inlineJava!dataType variableName!. For example, if we wanted to declare an integer variable named score, we'd write
\vspace{-15pt}
\begin{lstlisting}
int score;
\end{lstlisting}
\begin{defi}[Assigning variables]
    When we give a variable a value, this is called \term{assigning} the variable a value.
\end{defi}
In Java, we use the \inlineJava!=! symbol to assign variables, for example
\vspace{-15pt}
\begin{lstlisting}
score = 10;
\end{lstlisting}
We can declare and assign in the same line of code:
\vspace{-15pt}
\begin{lstlisting}
int score = 10;
\end{lstlisting}
Variables can be declared as \term{constant} by being preceded by the keyword \inlineJava!final!.
\vspace{-30pt}
\begin{lstlisting}
final double speedOfLight = 300000000;
\end{lstlisting}
\subsection{Arithmetic Operators}
Arithmetic operations take numeric values and output a numeric value of the same type. In Java, these can be done using the operators listed in figure \ref{fig:arithmeticOperations}.
\begin{figure}[H]
    \caption{Arithmetic operations in Java}
    \label{fig:arithmeticOperations}
    \centering
    \vspace{10pt}
    \begin{tabular}{|l|l|}
        \hline Operation & Java operator \\ \hline \hline
        Addition & \inlineJava!+! \\ \hline
        Subtraction & \inlineJava!-! \\ \hline
        Multiplication & \inlineJava!*! \\ \hline
        Division & \inlineJava!/! \\ \hline
        Remainder or Modulus & \inlineJava!%! \\ \hline
    \end{tabular}
\end{figure}
\begin{defi}[Overloading]
    A method or operator is said to be \term{overloaded} if it has multiple definitions, which may depend on context such as the data type or number of inputs.
\end{defi}
\begin{eg}The arithmetic operations are overloaded so we can use them on all of the primitive numeric types. For example \inlineJava!/! is defined for both \inlineJava!int! and \inlineJava!double!. In the \inlineJava!int! case, it returns a rounded down value, whereas in the \inlineJava!double! case it returns a precise (as possible given double precision) value: \inlineJava!3 / 2! will have value \inlineJava!1! of type \inlineJava!int!, but \inlineJava!3.0 / 2.0! will have value \inlineJava!1.5! of type \inlineJava!double!.
\end{eg}
\pagebreak
\subsection{Comparison Operators}
Comparison operations take numeric values and output a boolean value. In Java, these can be done using the operators listed in figure \ref{fig:comparisonOperations}.
\begin{figure}[H]
    \caption{Comparison operations in Java}
    \label{fig:comparisonOperations}
    \centering
    \vspace{10pt}
    \begin{tabular}{|l|l|}
        \hline Operation & Java operator \\ \hline \hline
        Equal to & \inlineJava!==! \\ \hline
        Not equal to & \inlineJava"!=" \\ \hline
        Less than & \inlineJava!<! \\ \hline
        Greater than & \inlineJava!>! \\ \hline
        Less than or equal to & \inlineJava!<=! \\ \hline
        Greater than or equal to & \inlineJava!>=! \\ \hline
    \end{tabular}
\end{figure}
\begin{note} The \inlineJava!==! operator (and by extension \inlineJava"!=") only compares the value for \emph{primitive types}. We will see later in section \ref{subsec:EqualityOperator} that for objects, \inlineJava!==! is unsuitable for comparing values.
    
\end{note}
\subsection{Logical Operators}
Logical operations take boolean values and output a boolean value. These can be done using the operators listed in figure \ref{fig:logicalOperations}.
\begin{figure}[H]
    \caption{Logical operations in Java}
    \label{fig:logicalOperations}
    \centering
    \vspace{10pt}
    \begin{tabular}{|l|l|}
        \hline Operation & Java operator \\ \hline \hline
        Logical NOT & \inlineJava"!" \\ \hline
        Logical OR & \inlineJava!||! \\ \hline
        Logical AND & \inlineJava!&&! \\ \hline
    \end{tabular}
\end{figure}

\pagebreak
\section{Program design}
\begin{defi}[Program Design and Implementation]
    \term{Program design} is working out how to go about developing software. \term{Implementation} is the process of developing the software.
\end{defi}
\subsection{Pseudocode}
\term{Pseudocode} refers to code written with very loose syntax, not bound by that of any specific language.
\begin{algorithm}
    \caption{An example of pseudocode to calculate a price after tax}
    \label{alg:pseudocodeExample1}
    \textbf{display} prompt for price\;
    price $\gets$ \textbf{user input}\;
    \textbf{display} prompt for tax percentage\;
    tax $\gets$ \textbf{user input}\;
    \textbf{return} price * (1 + tax/100)\;
\end{algorithm}
\begin{algorithm}
    \caption{An alternative way of writing the same algorithm as in algorithm \ref{alg:pseudocodeExample1}}
    DISPLAY prompt for price\;
    ENTER price\;
    DISPLAY prompt for tax percentage\;
    ENTER tax\;
    RETURN price * (1 + tax/100)\;
\end{algorithm}
\pagebreak


\section{Selection and Iteration}
\subsection{If Statements}
An \term{if statement} executes a piece of code conditional on a boolean condition. The Java syntax for an if statement is
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
if(!!!condition!!!)
{
    !!!code_if_condition_true!!!
}
\end{lstlisting}
\subsection{If-Else Statements}
An \term{if-else statement} executes a piece of code conditional on a boolean condition, and if not executes another piece of code. The Java syntax for an if-else statement is
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
if(!!!condition!!!)
{
    !!!code_if_condition_true!!!
}
else
{
    !!!code_if_condition_false!!!
}
\end{lstlisting}
\subsection{Switch Statements}
A \term{switch statement} is a switch between many pieces of code based on the value of a varaible. In Java, the syntax for a switch statement is
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
switch(!!!variable!!!)
{
    case !!!value1!!!: !!!code!!!
        break;
    ...
    case !!!valueN!!!: !!!code!!!
        break;
    default: !!!code!!!
        break;
}
\end{lstlisting}
\subsection{For Loops} \label{sec:forLoops}
A \term{for loop} iterates a piece of code a fixed number of times, with a varying parameter. The Java syntax for a for loop is
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
for(!!!initialisation!!!; !!!termination!!!; !!!increment!!!)
{
    !!!code!!!
}
\end{lstlisting}
The code in the header behaves as follows
\begin{itemize}
    \item \inlineJava"!!!initialisation!!!" runs once, at the beginning of the loop's execution
    \item \inlineJava"!!!termination!!!" should be a boolean expression: when this evaluates to \inlineJava!false! the loop will terminate.
    \item \inlineJava"!!!increment!!!" runs after each iteration of the loop
\end{itemize}
\begin{eg} A typical use of a for loop would be to add all the integers between 0 and 10. This would be written as follows
\begin{lstlisting}[caption=A typical use of a for loop, label=lst:forLoopDemo]
int total = 0;
for(int i = 0; i <= 10; i++)
{
    total += i;
}
\end{lstlisting}
In listing \ref{lst:forLoopDemo} we initialise a new variable \inlineJava!int i = 0!, and each iteration of the loop \inlineJava!i++! is executed, incrementing \inlineJava!i! by 1. The loop terminates when \inlineJava!i <= 10! no longer holds.
\end{eg}
\begin{note}
    When a variable is declared in the initialisation of a for loop, its scope is within that for loop.
\end{note}

\subsection{While loops}
A \term{while loop} iterates a piece of code while a boolean condition is true. The Java syntax for a for loop is
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
while(!!!condition!!!)
{
    !!!code!!!
}
\end{lstlisting}
\subsection{Do-While loops}
A \term{do-while loop} executes a piece of code once, then iterates it while a boolean condition is true. The Java syntax for a for loop is
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
do
{
    !!!code!!!
} while (!!!condition!!!)
\end{lstlisting}

\subsection{Break statements}
While inside a loop, you can use a \term{break statement} to terminate iteration of the loop.
\begin{eg} If you wanted to terminate a for loop when its counter reaches 3, you could write the following
\vspace{-15pt}
\begin{lstlisting}
for(int i = 0; i < 100; i++){
    if (i == 3)
    {
        break;
    }
}
\end{lstlisting}
\end{eg}

\subsection{Continue statements}
While inside a loop, you can use a \term{continue statement} to skip to the next iteration of the loop.
\begin{eg} If you wanted to skip an iteration in a for loop when its counter reaches 3, you could write the following
\vspace{-15pt}
\begin{lstlisting}
for(int i = 0; i < 100; i++){
    if (i == 3)
    {
        continue;
    }
}
\end{lstlisting}
\end{eg}
\pagebreak
\section{Methods}
\label{sec:methods}
\term{Methods} are pieces of code that perform some operation, possibly with parameters that affect that operation. The operation may return a result, or affect the state of the program. Methods can be \term{called} from elsewhere in the program to run their code, and they may be called multiple times.
\subsection{Declaring, Defining and Calling Methods}
Methods are defined using the following syntax:
\vspace{-15pt}
\begin{lstlisting}[style=javaSyntax]
!!!modifiers!!! !!!return_type!!! !!!method_name!!!(!!!parameters!!!) 
{
    !!!method_body!!!
}
\end{lstlisting}
Convention is that a method name will have the first letter lowercase. The first line of the method declaration is called the \term{method header}.
\begin{eg} We could use a method to take an integer and return it multiplied by 2.
\begin{lstlisting}[caption=An example method, label=lst:multByTwo]
public static int multByTwo(int x)
{
    return x * 2;
}
\end{lstlisting}
In this example \inlineJava!public! and \inlineJava!static! are modifiers, \inlineJava!int! is the return type, \inlineJava!multByTwo! is the method name, \inlineJava!int x! is the parameter, and \inlineJava!return x * 2;! is the method body.
\end{eg}
\noindent Methods are called using the following syntax:
\vspace{-15pt}
\begin{lstlisting}[style=javaSyntax]
!!!method_name!!!(!!!parameters!!!) 
\end{lstlisting}
\begin{eg} If we wanted to call the method in listing \ref{lst:multByTwo} to multiply 5 by 2 and assign it to variable \inlineJava!num!, we would write the following code.
\vspace{-15pt}
\begin{lstlisting}
int num = multByTwo(5);
\end{lstlisting}
We could call the method \inlineJava!multByTwo! twice if we so wished:
\vspace{-15pt}
\begin{lstlisting}
int num = multByTwo(multByTwo(5));
\end{lstlisting}
Methods may affect the state of the program, so sometimes we don't need to put the output into a variable. We may use \inlineJava!void! as the return type for such methods. Regardless, any method can also be run without assigning the return value to a variable. The following example would run the method multByTwo, but not put the return value in a variable.
\vspace{-15pt}
\begin{lstlisting}
multByTwo(5);
\end{lstlisting}
\end{eg}
\subsection{Modifiers for Methods}
In a method header in Java, you can use \term{modifiers} to modify various behaviours of the method: one \term{access modifier} then potentially a combination of \term{non-access modifier}s. The access modifiers are as follows
\begin{itemize}
    \item \inlineJava"default" (if you don't specify a modifier) - The method is accessible only in the same package.
    \item \inlineJava"public" - The method is accessible in all classes.
    \item \inlineJava"private" - The method is only accessible in the declared class.
    \item \inlineJava"protected" - The method is accessible in the same package and subclasses.
\end{itemize}
The non-access modifiers are
\begin{itemize}
    \item \inlineJava"final" - The method cannot be overridden or modified.
    \item \inlineJava"static" - The method belongs to the class rather than objects of that class.
    \item \inlineJava"abstract" (can only be used in an abstract class) - The method has no method body, which must be supplied by any subclass.
    \item \inlineJava"transient" - Makes the method ignored when serialising the object containing it.
    \item \inlineJava"synchronized" - The method can be accessed only by a single thread at a time.
\end{itemize}
\pagebreak
\subsection{Method Overloading}
It is allowed in Java to give multiple methods the same name, as long as they accept a different set of parameters. This is called \term{overloading}. For example, the following is valid Java code.
\begin{lstlisting}
static int max(int firstIn, int secondIn)
{
    if(firstIn > secondIn)
    {
        return firstIn;
    }
    else
    {
        return secondIn;
    }
}

static int max(int firstIn, int secondIn, int thirdIn)
{
    return(max(firstIn, max(secondIn, thirdIn)))
}
\end{lstlisting}
\begin{defi}[Polymorphism]
    Methods and operators with the same name being allowed to perform different function is called \term{polymorphism}.
\end{defi}
\pagebreak
\section{Classes and Objects}
\label{sec:classesAndObjects}
In definition \ref{def:OOP}, we defined object oriented programming, and said, objects may contain both data (fields, attributes or properties), and code (methods). The idea is that a \term{class} is a blueprint for an \term{object}. 
\subsection{Class Declaration}
The syntax for class declaration is as follows:
\vspace{-15pt}
\begin{lstlisting}[style=javaSyntax]
!!!modifiers!!! class !!!class_name!!!
{
    !!!class_body!!!
}
\end{lstlisting}
Convention is that a class name will have the first letter capitalised.
\subsection{The Class Body}
The class body may consist of method and attribute declarations. You may also provide a special method called a \term{constructor}, which has the same name as the class, and the return type is not written. For example, if we were to run a physics simulation of an object with mass under a gravitational force, a class \inlineJava!PhysicsObject! may be defined as follows
\begin{lstlisting}[caption=PhysicsObject, label=lst:PhysicsObject]
public class PhysicsObject
{
    private double mass;
    private static double gravity = 9.81;

    public PhysicsObject(double massIn){
        mass = massIn;
    }

    public static void setGravity(double gravityIn){
        gravity = gravityIn;
    }

    public double getGravityForce(){
        return mass * gravityConst;
    }   
}
\end{lstlisting}
Notice that we have declared the attributes as private, so the only way to access the attributes are through the class' methods. This kind of data protection is called \term{encapsulation}. \\ Also, we have \term{initialised} the \inlineJava{gravity} attribute, which sets the value at the start of the lifetime of the \inlineJava!PhysicsObject! class, or if it were not \inlineJava!static!, at the start of the lifetime of each \inlineJava!PhysicsObject! object. Java always initialises attributes to a given value, numerical primitives to 0, \inlineJava!boolean! to \inlineJava!false!, \inlineJava!Object! to \inlineJava!null!
\subsection{Instantiating an object}
Creating a new object is called \term{instantiation}. This is achieved in Java as follows
\vspace{-30pt}
\begin{lstlisting}[style=javaSyntax]
!!!class_name!!! !!!object_name!!! = new !!!class_name!!!(!!!parameters!!!)
\end{lstlisting}
For example, to create an object called \inlineJava"box" of the \inlineJava"PhysicsObject" class above, with mass 5.0, we would write
\vspace{-15pt}
\begin{lstlisting}
PhysicsObject box = new PhysicsObject(5.0)
\end{lstlisting}

\subsection{Accessing the Public Methods and Attributes of an Object or Class}
To access the public methods of an object we have instantiated, we use the \term{dot operator}.
\vspace{-22pt}
\begin{lstlisting}[style=javaSyntax]
!!!object_name!!!.!!!method_name!!!(!!!parameters!!!)
\end{lstlisting}
Similarly for attributes we use
\vspace{-22pt}
\begin{lstlisting}[style=javaSyntax]
object_name.attribute_name
\end{lstlisting}
For example, to get the force acting on our box
\vspace{-15pt}
\begin{lstlisting}
double force = box.getGravityForce();
\end{lstlisting}
If the \inlineJava!static! modifier has been used in the definition, instead we need to refer to the class name rather than the object name, for example, to set the gravity constant to 1, we would write
\vspace{-15pt}
\begin{lstlisting}
PhysicsObject.setGravity(1.0);
\end{lstlisting}
\subsection{The "this" keyword}
The \index{this keyword} \inlineJava!this! keyword refers to the object which owns a method or constructor. It is useful to distinguish between class attributes and parameters with the same name. 
\subsection{Modifiers for Classes}
When declaring an class, you can use \term{modifiers} to modify various behaviours of the class: one \term{access modifier} then potentially a combination of \term{non-access modifier}s. The access modifiers are as follows
\begin{itemize}
    \item \inlineJava"default" (if you don't specify a modifier) - The class is accessible only by classes in the same package.
    \item \inlineJava"public" - The class is accessible in any other class.
\end{itemize}
The non-access modifiers are
\begin{itemize}
    \item \inlineJava"final" - The class cannot be inherited by other classes.
    \item \inlineJava"abstract" - Objects of this class cannot be created.
\end{itemize}


\subsection{Modifiers for Attributes}
When declaring an attribute, you can use \term{modifiers} to modify various behaviours of the attribute: one \term{access modifier} then potentially a combination of \term{non-access modifier}s. The access modifiers are as follows
\begin{itemize}
    \item \inlineJava"default" (if you don't specify a modifier) - The attribute is accessible only in the same package.
    \item \inlineJava"public" - The attribute is accessible in all classes.
    \item \inlineJava"private" - The attribute is only accessible in the declared class.
    \item \inlineJava"protected" - The attribute is accessible in the same package and subclasses.
\end{itemize}
The non-access modifiers are
\begin{itemize}
    \item \inlineJava"final" - The attribute cannot be overridden or modified.
    \item \inlineJava"static" - The attribute belongs to the class rather than objects of that class.
    \item \inlineJava"transient" - Makes the attribute ignored when serialising the object containing it.
    \item \inlineJava"synchronized" - The attribute can be accessed only by a single thread at a time.
    \item \inlineJava"volatile" - The attribute is always read from main memory, not from a thread-local cache. In practice, this means any thread will be able to read the most recently updated value for this attribute.
\end{itemize}
\section{Inheritance}
\subsection{Superclasses and Subclasses}
Often we wish to make classes which represent a "kind of" another class. To do this, we use inheritance.
\begin{defi}[Inheritance]
\term{Inheritance} refers to fields and methods being shared between classes. In particular, a newly defined class, the \term{subclass}, will have the fields and methods of some previously defined class, the \term{superclass}, but can also implement new fields and methods of its own.
\end{defi} 
\noindent In Java, the syntax used for inheritance is the \inlineJava!extends! keyword, 
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
!!!modifiers!!! class !!!subclass!!! extends !!!superclass!!!
{
    !!!code!!!
}
\end{lstlisting}
\begin{eg}
    We define a class \inlineJava"Book" with fields \inlineJava"title" and \inlineJava"contents" which are both of type \inlineJava"String", as well as a constructor which sets these values, and a method \inlineJava"display" which prints to console the title and contents of the book
\begin{lstlisting}[caption=Book,label=lst:Book]
public class Book
{
    private String title;
    private String contents;

    public Book(String title, String contents){
        this.title = title;
        this.contents = contents;
    }

    public void display(){
        System.out.println("Title: " + title);
        System.out.println("Contents: " + contents);
    }
}
\end{lstlisting}
Suppose we further wanted to define a class \inlineJava"Textbook" which is a book with an extra \inlineJava"String" field \inlineJava"subject", and a new constructor. We would use inheritance as follows:
\pagebreak
\begin{lstlisting}[caption = Textbook, label=lst:Textbook1]
public class Textbook extends Book
{
    private String subject;

    public Textbook(String title, String contents, String subject){
        this.title = title;
        this.contents = contents;
        this.subject = subject;
    }
}
\end{lstlisting}
\end{eg}
\subsection{Method Overriding}
In a subclass, we can redefine some methods that are already defined in the superclass, in particular, those with the \inlineJava"public" or \inlineJava"protected" modifier (or \inlineJava"default" if the superclass lies in the same package as the subclass). To override a method in Java, you need only define the method as usual, although you can optionally add the \inlineJava"@Override" annotation beforehand, which tells the compiler to check that this method name has been used in the superclass.
\begin{eg}
    As it stands,  the \inlineJava"Textbook" class is not very useful, as the \inlineJava"display()" method does not show the subject, so we override it
\begin{lstlisting}[caption = Textbook, label=lst:Textbook2]
public class Textbook extends Book
{
    private String subject;

    public Textbook(String title, String contents, String subject){
        this.title = title;
        this.contents = contents;
        this.subject = subject;
    }

    @Override
    public void display(){
        System.out.println("Title: " + title);
        System.out.println("Subject: " + subject);
        System.out.println("Contents: " + contents);
    }
}
\end{lstlisting}
\end{eg}

\pagebreak
\section{Assignment and Equality}
\subsection{The Assignment Operator (=)}
\index{= operator}\index{assignment operator}The \inlineJava!=! operator assigns a value to a variable. For example, the following assigns the value 10 to \inlineJava!x!.
\vspace{-15pt}
\begin{lstlisting}
int x = 10;
\end{lstlisting}
When dealing with objects instead of primitives, the value that is assigned is the memory address of the object on the right hand side.
\begin{eg} Suppose we have a class \inlineJava!Rectangle!
\begin{lstlisting}[caption=Rectangle, label=lst:Rectangle]
public class Rectangle
{
    private double length;
    private double width;

    public Rectangle(double length, double width)
    {
        this.length = length;
        this.width = width;
    }

    public setLength(double length)
    {
        this.length = length;
    }

    public setWidth(double width)
    {
        this.width = width;
    }
    
    public double getArea()
    {
        return length*width;
    }
}
\end{lstlisting}
\pagebreak
The listing \ref{lst:assignmentOperatorObject}, line 1 creates a new \inlineJava!Rectangle! in memory with length 1.0 and width 1.0, and assign \inlineJava!rect! to its memory address.
\\ In line 2, \inlineJava!rect2! would be assigned the value of \inlineJava!rect!, i.e. the memory address of the rectangle.
\\ Then in line 3, we use the \inlineJava!setWidth! method to set \inlineJava!rect2.width! to 5.0. As \inlineJava!rect2! points to the same object as \inlineJava!rect!, this method sets \inlineJava!rect.width! to 5.0.
\\ In line 4, we set \inlineJava!area! to \inlineJava!rect.getArea()!. This returns \inlineJava!5.0!, as \inlineJava!rect.length! is 1.0 and \inlineJava!rect.width! is 5.0.
\begin{lstlisting}[caption=A sample of code to interact with the Rectangle class, label=lst:assignmentOperatorObject] 
Rectangle rect = new Rectangle(1.0,1.0);
Rectangle rect2 = rect;
rect2.setWidth(5.0);
double area = rect.getArea();
\end{lstlisting}
\end{eg}
\begin{defi}[Aliasing]
\term{Aliasing} is when an object is assigned multiple names. In listing \ref{lst:assignmentOperatorObject}, we see \inlineJava!rect2! is an \term{alias} of \inlineJava!rect!.
\end{defi}
\subsection{The new Keyword}
The \term{new keyword} creates a new object, at runtime it assigns an area in memory on the heap to store that object, and returns a reference to that object. It has one argument, being the constructor of the object to be initialised.

\subsection{The Equality Operator (==)} \label{subsec:EqualityOperator}
\index{== operator}\index{equality operator}The \inlineJava!==! operator will tell you if two non-null references refer to the same object in memory. This is called \term{reference equality}. In practice, this means that when comparing objects using \inlineJava!==!, you are comparing their memory address, not their data. \textbf{WARNING: It is a common mistake to use \inlineJava!==! to compare the data contained by an object. You should instead use a method which compares the data you require to be compared (often the overridden \inlineJava!equals! method).} With the following declarations, we would have that \inlineJava!a==b! would return \inlineJava!true!, but \inlineJava!a==c! would return \inlineJava!false!, despite \inlineJava!a! and \inlineJava!c! containing the same data!
\vspace{-15pt}
\begin{lstlisting}
String a = new String("str");
String b = a;
String c = new String("str");
\end{lstlisting}
In contrast, for primitives, the \inlineJava!==! operator returns the \term{value equality}, i.e. true if and only if the variables contain the same value.
\section{Common Classes}
\subsection{Object}
Every class is a subclass of \inlineJava!Object!, so inherits its methods. Examples of such methods are 
\begin{itemize}
    \item \inlineJava!public boolean equals(Object obj)! - Returns true if the current object is equal to \inlineJava!obj!. The equals method for the class \inlineJava!Object! this is the same as the  \inlineJava!==! operator. \textbf{WARNING: This means that two objects may be indistinguishable by the data and methods they hold, but are still distinguished by the equals method!} As a result, for most classes the equals method is overriden.
    \item \inlineJava!protected Object clone()! - Produces a clone of the current object, such that \inlineJava!x.clone() == x! will return false.
    \item \inlineJava!public String toString()! - Returns a string representation of the object. Usually overridden to give more useful information.
\end{itemize}
\subsection{String}
A \term{string} is a sequence of characters. The \inlineJava{String} class represents \term{immutable} strings, that is, they cannot be modified by methods.
\begin{defi}[String Literal]
    A \term{string literal} is a piece of code which represents a fixed string. 
\end{defi}
In Java, string literals are represented as a string within quotation marks, for example \inlineJava!"This is a string literal"!. String literals are implemented as instances of the class \inlineJava!String!. 
\par Use of the same string literal twice will reference to the same \inlineJava!String! object in memory. For example, with the following declarations, \inlineJava!a == b! would return \inlineJava!true!.
\vspace{-15pt}
\begin{lstlisting}
String a = "str"
String b = "str"
\end{lstlisting}
The string class has many associated methods, such as:
\begin{itemize}
    \item \inlineJava!public int length()! - Returns the length of the string.
    \item \inlineJava!public boolean equals(Object obj)! - Returns true if and only if \inlineJava!obj! is a \inlineJava!String! object and has the same value as the current string. Overrides the \inlineJava!equals! method for the \inlineJava!Object! class.
    \item \inlineJava!public String substring(int beginIndex, int endIndex)! - \newline Returns the substring of this string beginning with the \inlineJava!beginIndex!$^{\text{th}}$ character, ending with the  \inlineJava!(endIndex-1)!$^{\text{th}}$ character.
    \item \inlineJava!public String toLowerCase()! - Returns the string in lowercase.
    \item \inlineJava!public String toUpperCase()! - Returns the string in uppercase.
\end{itemize}
\subsection{Wrappers}
For each primitive data type, there is a \term{wrapper class} which hold a single field of the corresponding primitive type.
\begin{figure}[H]
    \caption{The wrapper classes}
    \label{fig:wrappers}
    \centering
    \vspace{10pt}
    \begin{tabular}{|l|l|}
    \hline
    Primitive Type & Wrapper Class \\ \hline \hline
    byte & Byte \\ \hline
    short & Short \\ \hline
    int & Integer \\ \hline
    long & Long \\ \hline
    float & Float \\ \hline
    double & Double \\ \hline
    boolean & Boolean \\ \hline
    char & Character \\ \hline
    \end{tabular}
\end{figure}
\term{Autoboxing} allows us to use primitive values in place of wrapper objects, and \term{unboxing} allows vice versa.
\subsection{Scanner}
The \term{Scanner class} allows text input to the program, with ability to parse primitive types, and use regular expressions to parse strings. Scanners can scan from user input to a console, from files, and from String objects. \par This class comes in a package called \inlineJava!util!.  We use the \index{import keyword}\inlineJava!import! keyword to import packages.
\vspace{-15pt}
\begin{lstlisting}
import java.util.Scanner;
\end{lstlisting}
or we can use an asterisk to import the whole package
\vspace{-15pt}
\begin{lstlisting}
import java.util.*;
\end{lstlisting}
\begin{lstlisting}[caption=Sample use of the Scanner class, label=lst:scannerExample]
Scanner sc = new Scanner(System.in);
int i = sc.nextInt();
long j = sc.nextLong();
String k = sc.next();
System.out.println(i + ", " + j + ", " + k);
sc.close();
\end{lstlisting}
In listing \ref{lst:scannerExample}, 3 user inputs are taken from the console, and they are outputted separated by commas.

\section{Arrays}
An \term{array} stores a fixed number of values of the same type. 
\begin{note}
    Arrays do not entirely follow object oriented philosophy, we will look at other collection structures that conform to the object oriented philosophy much better.
\end{note}
\noindent In Java, the syntax to declare an array is to use square brackets after the type declaration.
\vspace{-22pt}
\begin{lstlisting}[style=javaSyntax]
!!!type!!![] !!!array_name!!!; 
\end{lstlisting}
\subsection{Assigning Arrays}
There are multiple ways to assign an array in Java. 
\vspace{5pt} \\ To assign an array with all default values,
\vspace{-22pt}
\begin{lstlisting}[style=javaSyntax]
!!!array_name!!! = new !!!type!!![!!!capacity!!!]; 
\end{lstlisting}
To assign an array using an array literal,
\vspace{-22pt}
\begin{lstlisting}[style=javaSyntax]
!!!array_name!!! = {!!!comma_separated_values!!!}; 
\end{lstlisting}
Alternatively, you can write
\vspace{-22pt}
\begin{lstlisting}[style=javaSyntax]
!!!array_name!!! = new type[]{!!!comma_separated_values!!!}; 
\end{lstlisting}
Like variables, you can do the declaration and assignment in one line.
\begin{egs} Array declarations and assignments
\vspace{-15pt}
\begin{lstlisting}
int[] a = {1,2,3};
double[] b;
b = new double[5];
char[] c = new char[] {'A', 'Z'};
\end{lstlisting}
\end{egs}
\subsection{Accessing Array Elements}
To access the $i^{th}$ element of an array called \inlineJava!array_name! in Java, we use square brackets
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
!!!array_name!!![!!!i!!!]
\end{lstlisting}
Note that array indices start from 0, so in the previous example, \inlineJava!a[0]! is 1 and \inlineJava!c[1]! is \inlineJava!'Z'!.
\subsection{Arrays of Objects}
An array of objects is in fact an array of references, in particular, the array can contain multiple of the same reference, so can refer to the same object multiple times.
\subsection{Multi-dimensional Arrays}
A \term{multi-dimensional array} is an array of arrays, which may themselves be multi-dimensional arrays. In Java, to declare a 2-dimensional array, we would write the following
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
!!!type!!![][] !!!array_name!!!; 
\end{lstlisting}
For more dimensions, we would write more square brackets.
\begin{defi}[Jagged and Rectangular Arrays]
\index{rectangular array}\index{jagged array}A multi-dimensional array is \emph{rectangular} if in each dimension it always has the same length. Otherwise, the array is called \emph{jagged}.
\end{defi}
\noindent We can assign multi-dimensional arrays similarly to 1-dimensional arrays, here we do 2-dimensional arrays.
\vspace{5pt} \\ To assign a rectangular 2-dimensional array of dimensions \inlineJava!capacity_x! and \inlineJava!capacity_y!, with all default values,
\vspace{-22pt}
\begin{lstlisting}[style=javaSyntax]
!!!array_name!!! = new !!!type!!![!!!capacity_x!!!][!!!capacity_y!!!]; 
\end{lstlisting}
You may also assign the length of each element of the array separately to form a jagged array, for example to declare a new array of \inlineJava!capacity_x! arrays, where the $i^{th}$ had capacicty \inlineJava!capacity_y_i!, the following would be written.
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
!!!array_name!!! = new !!!type!!![!!!capacity_x!!!][];
!!!array_name!!![!!!i!!!] = new !!!type!!![!!!capacity_y_i!!!];
\end{lstlisting}
You can also assign a 2-dimensional array using array literals,
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
!!!array_name!!! = {!!!comma_separated_arrays!!!}; 
\end{lstlisting}
\pagebreak
To access the elements, we use the same syntax as for 1-dimensional arrays
\vspace{-20pt}
\begin{lstlisting}[style=javaSyntax]
!!!array_name!!![!!!i!!!][!!!j!!!] 
\end{lstlisting}
All of this notation extends to higher-dimensional arrays by increasing the number of square brackets
\begin{egs} If we wanted to create a rectangular array of doubles called \inlineJava!a!, with dimensions 3 and 4, containing all 0s, we would write
\vspace{-15pt}
\begin{lstlisting}
double[][] a = new double[3][4];
\end{lstlisting}
If we wanted to create a jagged array of integers called \inlineJava!a!, with 4 rows, and the $i^{th}$ row has $i$ columns, and \inlineJava!a[i][j]! has value \inlineJava!i+j!, we could write the following
\vspace{-15pt}
\begin{lstlisting}
int[][] a = new int[4][];
for(i = 0; i < 4; i++)
{
    a[i] = new int[i];
    for(j = 0; j < i; j++)
    {
        a[i][j] = i + j;
    }
}
\end{lstlisting}
Alternatively, we would get the same result by the following
\vspace{-15pt}
\begin{lstlisting}
int[][] a = 
{
    {},
    {1},
    {2,3},
    {3,4,5}
};
\end{lstlisting}
\end{egs}
\pagebreak
\section{Dynamically Sized Collections}
Arrays can be quite limiting, as they have a fixed number of elements. To get around this, we instead use a data structure that can store an arbitrary number of elements.
\subsection{ArrayList}
One example of a dynamically sized collection in Java is \term{ArrayList} in the \inline"util" package
\vspace{-15pt}
\begin{lstlisting}
import java.util.ArrayList;
\end{lstlisting}
An \inlineJava{ArrayList<T>} object stores an array of type \inlineJava"T", and if an index needs to be accessed beyond the array's size, dynamically resizes the array. As a result, we obtain a data structure that can store an arbitrary number of elements.
\pagebreak
\chapter{Algorithms \& Data Structures}
\section*{Preamble}
In this and further chapters, I will make use of various logical symbols, figure \ref{fig:logicalSymbols} indicates their meanings
\begin{figure}[H]
    \caption{Logical symbols}
    \label{fig:logicalSymbols}
    \centering
    \begin{tabular}{|c|l|}
        \hline
        Symbol & Meaning \\
        \hline \hline
        $\top$ & True \\ \hline
        $\bot$ & False \\ \hline
        $\wedge$ & Logical and \\ \hline
        $\vee$ & Logical or \\ \hline
        $\veebar$ & Logical xor \\ \hline
        $\neg$ & Logical not \\ \hline
        $\forall$ & For all \\ \hline
        $\exists$ & There exists \\ \hline
        $\exists!$ & There exists a unique \\ \hline
        $\not\exists$ & There does not exist \\ \hline
        $\implies$ & Logically implies \\ \hline
        $\iff$ & Logically equivalent to/If and only if \\ \hline
        $=$ & Propositionally equals \\ \hline
        $:=$ & Is defined as \\ \hline
        $\in$ & Is an element of \\ \hline
        $\subseteq$ & Is a subset of \\ \hline
        $\supseteq$ & Is a superset of \\ \hline
    \end{tabular}
\end{figure}
\section{Introduction}
\begin{defi}[Computational Problem]
    A \term{computational problem} is a specified desired output of a computer program given specified input data.
\end{defi}
\begin{defi}[Algorithm]
    An \term{algorithm} is a set of instructions. In our use case, an algorithm must consist of basic instructions which a computer can carry out.
\end{defi}
Here is an example computational problem:
\begin{nproblem}[The Maximum Problem] Given a finite sequence of integers, find the maximum
    \mypar
    \textbf{Input: }A sequence $(a_1,\dots,a_n)$ of integers.
    \mypar \textbf{Output: }$a_k$ such that $\forall i \in \{1,\dots,n\}, \ a_k \geq a_i$.
\end{nproblem}
\begin{algEng}[Maximum Problem] The idea is to store a varaible which stores the maximum so far as we search the sequence, and compare each new element to this.
    \begin{enumerate}
        \item Decalare a variable \inline{currentMax}
        \item Set \inline{currentMax} to $a_1$.
        \item For each $i \in \{2,\dots,n\}$, if $a_i > $ \inline{currentMax} then set \inline{currentMax} to $a_i$.
        \item Return \inline{currentMax}.
    \end{enumerate}
\end{algEng}
\subsection{Psuedocode}
Pseudocode is a language with very loose syntax, designed to be easily readable to humans. We use the following conventions, but diferrent people use different conventions.
\begin{itemize}
    \item We use = for assignment, == for equality. 
    \item The body of a loop, if-statement or if-else-statment will be indented
    \item // indicates a line comment, and /* */ indicate a block comment.
    \item Variables have scope restricted to the current procedure.
    \item Objects are assigned by reference, i.e. if $x$ is an object, and we use the assignment $y \gets x$, then $y$ and $x$ refer to the same object.
    \item Objects are passed by reference.
    \item \inline{NIL} is a reference to a null object.
    \item Parameters are passed by value.
    \item Arrays are treated as objects.
    \item We can refer to elements of an array using square brackets.
    \item The \textbf{return} keyword will return control to the calling method. It may also return one or many values.
    \item Boolean operators are \term{short-circuiting}, they evaluate from left to right, and will return a value as soon as their value is determined.
    \item The \textbf{error} keyword is used to indicate an error. The calling procedure will handle errors.
\end{itemize}
\begin{eg}
    Suppose the data we would like to find the maximum of is stored in an array $A$ of length $n$. We could write the previous algorithm in pseudocode as follows.
    \begin{algorithm}
        \caption{max($A$)}
        \label{alg:max}
        $\text{currentMax} = A[1]$\;
        \For{$i = 2$ \KwTo $n$}
        {\If{currentMax $< A[i]$}
            {
                currentMax $= A[i]$\; 
            }
        }
        \Return currentMax\;
    \end{algorithm}
\end{eg}
\pagebreak
\subsection{Algorithm Analysis}
\subsubsection{The Experimental Approach}
The experimental approach to algorithm analysis is to implement the algorithm, then measure the time taken for the algorithm to give output on a range of test data. This data can then be analysed using a range of methods such as data plots.
\mypar The experimental approach has the following limitations
\begin{itemize}
    \item The algorithm must be implemented.
    \item It takes time to run the algorithm.
    \item Results will be limited to the specific data tested in the experiment.
    \item Results are dependent of hardware and software environments.
\end{itemize}
\subsubsection{The Theoretical Approach}
The theoretical approach is to use a mathematical description of the algorithm, and then calculate the theoretical running time of the algorithm. When taking this approach, we make the following assumptions
\begin{itemize}
    \item We use a \term{random access machine} model, that is, the CPU can access arbitrarily many memory cells in constant time, given an address.
    \item Instructions are executed in series.
    \item Basic instructions such as evaluating expressions, assigning value to variables, indexing an array, calling methods and returning from methods are considered to have constant time cost.
\end{itemize}
We analyse pseudocode, giving each line a time cost, and calculate the number of times that line will run.
\begin{eg}
    An analysis of algorithm \ref{alg:max}. $\text{Time} = a+e + (b+c+d)(n-1)$.\\
    \begin{algorithm}[H]
        \caption{max($A$)} 
        $\text{currentMax} = A[1]$\tcp*{cost a, times 1}
        \For(\tcp*[f]{cost b, times n-1}){$i = 2$ \KwTo $n$}
        {\If(\tcp*[f]{cost c, times n-1}){currentMax $< A[i]$}
            {
                currentMax $= A[i]$\tcp*{cost d, times n-1} 
            }
        }
        \Return currentMax\tcp*{cost e, times 1} 
    \end{algorithm}
\end{eg}
\pagebreak
\subsubsection{Asymptotic Bounds on Running Times}
When analysing the time cost or memory usage of programs, the constants are often unimportant. Hence we often classify these using \term{asymptotic bounds}, which tell us about the behaviour of our programs with large inputs. 
\begin{intuition}
    We define a notation, big-Theta. $f(x) = \Theta(g(x))$ means, for large inputs, $f(x)$ grows at approximately the same relative rate as $g(x)$. In practice, this means we can ignore all but the fastest growing term in the formula for $f(x)$.
    \\ To come up with a proper definition, we define two weaker notions, big-O and big-Omega. $f(x) = O(g(x))$ means, for large inputs, $f(x)$ grows at a slower or equal relative rate as $g(x)$, and $f(x) = \Omega(g(x))$ means, for large inputs, $f(x)$ grows at a faster or equal relative rate as $g(x)$.
    \\ In practice, we use big-O and big-Omega for things that may vary based on the input of the algorithm, such as running time, and use big-Theta for things that do not depend on the input, for example best/worst case running times.
\end{intuition}
\begin{egs}  Correct usage of Big-Theta notation.
    \begin{itemize}
        \item $x^2 + 2x + 1 = \Theta(x^2)$ 
        \item $2^x + x^{99} = \Theta(2^x)$ 
        \item $x\log(x) + x = \Theta(x\log(x))$ 
    \end{itemize}
    Correct usage of Big-O notation.
    \begin{itemize}
        \item $x^2 + 2x + 1 = O(x^4)$ 
        \item $2^x + x^{99} = O(2^x)$ 
        \item $x\log(x) + x = O(x^2)$ 
    \end{itemize}
    Correct usage of Big-Omega notation.
    \begin{itemize}
        \item $x^2 + 2x + 1 = \Omega(x)$ 
        \item $2^x + x^{99} = \Omega(2^x)$ 
        \item $x\log(x) + x = \Omega(1)$ 
    \end{itemize}
\end{egs}
\begin{eg}
    We calculated the time cost of algorithm \ref{alg:max} to be $a+e+(b+c+d)n$ for input an array of length $n$, for some constants $a,b,c,d$ and $e$.
    We see that this grows linearly, independent of input, so the time cost is $\Theta(n)$.
\end{eg}
\pagebreak
\begin{eg} A problem, algorithm, and time cost analysis.
    \begin{nproblem}
        [The Array Element Problem] Given an array $A$ and a value $x$, determine if $x$ is an element of $A$. 
        \mypar
        \textbf{Input: }An array $A$ and value $x$
        \mypar
        \textbf{Output: }True if $x$ is in $A$, False otherwise. 
    \end{nproblem}
    Let $A.length = n$.\mypar
    \begin{algorithm}[H]
        \caption{LinearSearch($A, x$)}
        \label{alg:LinearSearch}
        $i = 0$\tcp*{cost a, times 1}
        \While(\tcp*[f]{cost b, 1 <= times <= n}){$i < n$}
        {
            \If(\tcp*[f]{cost c, 1 <= times <= n}){$A[i] == x$}
            {
                \Return True\tcp*{cost d, times <= 1}
            }
        }
        \Return False\tcp*{cost e, times <= 1}
    \end{algorithm}
    \mypar
    We see that, worst case, we have time cost 
    \[a+d+e+(b+c)n = \Theta(n)\]
    In best case, we have time cost 
    \[a+b+c+d = \Theta(1)\]
    So we can make the following statements:
    \begin{itemize}
        \item The time cost of LinearSearch is $O(n)$.
        \item The time cost of LinearSearch is $\Omega(1)$.
        \item The best-case time costs of LinearSearch is $\Theta(1)$.
        \item The worst-case time cost of LinearSearch is $\Theta(n)$.
    \end{itemize}
\end{eg}
\pagebreak
\subsubsection{Precise Definitions of Asymptotic Bounds}
Following are precise mathematical definitions, these are not entirely necessary unless dealing with particularly nasty algorithms.
\begin{defi}[Asymptotic Bound]
    We say a function $f$ is asymptotically upper bounded by a function $g$, written $f \lesssim g$, if eventually $f(x)$ is always less than $g(x)$. i.e.
    \[\exists t, \ x > t \implies f(x) < g(x) \]
    Similarly, we say a function $f$ is asymptotically lower bounded by a function $g$, written $f \gtrsim g$, if eventually $f(x)$ is always less than $g(x)$. i.e.
    \[\exists t, \ x > t \implies f(x) > g(x) \]
\end{defi}
\begin{defi}
    [Big-O]
    We say a function $f$ is \term{big-O} of $g$, written $f(x) = O(g(x))$, if there is a constant $c$ such that $f$ is asymptotically upper bounded by $c\times g(x)$, i.e.
    \[\exists c, \ f(x) \lesssim c \times g(x) \]
\end{defi}
\begin{defi}
    [Big-Omega]
    We say a function $f$ is \term{big-Omega} of $g$, written $f(x) = \Omega(g(x))$, if there is a constant $c$ such that $f$ is asymptotically lower bounded by $c\times g(x)$, i.e.
    \[\exists c, \ f(x) \gtrsim c \times g(x) \]
\end{defi}
\begin{defi}
    [Big-Theta]
    We say a function $f$ is \term{big-Theta} of $g$, written $f(x) = \Theta(g(x))$, if it is both big-O and big-Omega of $g$.
\end{defi}
\pagebreak
\section{Stacks and Queues}
\begin{defi}[Stack]
    A \term{stack} is a collection equipped with two operations.
    \begin{itemize}
        \item \term{push} adds an element.
        \item \term{pop} reads and removes the last added element.
    \end{itemize}
    It is sometimes called a \term{LIFO} or \term{last-in-first-out} collection. 
\end{defi}
\begin{impl}[Array-Based Stack] The idea of an \term{array-based stack} is that we can store a pointer to the top of the stack, and use this to implement Push and Pop in $O(1)$ time. Below we use an implementation that checks for underflows, but not overflows (although in this case it can be passed to the array's overflow handling).
    \\ A stack $S$ will have 2 attributes: an array $S$, of size $S.length$, and a positive integer $S.top$.
    \mypar
    \begin{algorithm}[H]
        \caption{Stack-Empty($S$)}
        \uIf{$S.top == 0$}{\Return True\;}
        \Else{\Return False\;}
    \end{algorithm}
    \begin{algorithm}[H]
        \caption{Push($S, x$)}
        $S.top = S.top + 1$\;
        $S[S.top] = x$\;
    \end{algorithm}
    \begin{algorithm}[H]
        \caption{Pop($S$)}
        \uIf{Stack-Empty($S$)}
        {
            \Error Underflow\;
        }
        \Else
        {
            $S.top = S.top - 1$\;
            \Return{$S[S.top+1]$}\;
        }
    \end{algorithm}
    \begin{figure}[H]
        \caption{A diagram illustrating Array-Based Stacks}
        \centering
        \begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw, line width = 1pt, anchor=center}]
            \node (A) {Start};
            \node[below = 0.2cm of A] (SText) {$S$};
            \node[stack=7, below = 0cm of SText] (s) {
            \nodepart{four}d
            \nodepart{five}c
            \nodepart{six}b
            \nodepart{seven}a
            };
            \node[right = 0.5cm of s.four east] (STopText) {$S.top$};
            \draw[->,line width = 1pt] (STopText.west) -- (s.four east);

            \node[right = 1cm of A] (B) {$S.push$  x};
            \node[below = 0.2cm of B] (STextB) {$S$};
            \node[stack=7, below = 0cm of STextB] (sB) {
            \nodepart{three}x
            \nodepart{four}d
            \nodepart{five}c
            \nodepart{six}b
            \nodepart{seven}a
            };
            \node[right = 0.5cm of sB.three east] (STopTextB) {$S.top$};
            \draw[->,line width = 1pt] (STopTextB.west) -- (sB.three east);

            \node[right = 1cm of B] (C) {$S.pop$};
            \node[below = 0.2cm of C] (STextC) {$S$};
            \node[stack=7, below = 0cm of STextC] (sC) {
            \nodepart{three}{\color{lightgray} x}
            \nodepart{four}d
            \nodepart{five}c
            \nodepart{six}b
            \nodepart{seven}a
            };
            \node[right = 0.5cm of sC.four east] (STopTextC) {$S.top$};
            \draw[->,line width = 1pt] (STopTextC.west) -- (sC.four east);
            \node[below = 0.2cm of sC] (returnC) {return x};

            \node[right = 1cm of C] (D) {$S.push$  y};
            \node[below = 0.2cm of D] (STextD) {$S$};
            \node[stack=7, below = 0cm of STextD] (sD) {
            \nodepart{three}y
            \nodepart{four}d
            \nodepart{five}c
            \nodepart{six}b
            \nodepart{seven}a
            };
            \node[right = 0.5cm of sD.three east] (STopTextD) {$S.top$};
            \draw[->,line width = 1pt] (STopTextD.west) -- (sD.three east);

        \end{tikzpicture}
    \end{figure}
\end{impl}

\begin{defi}[Queue]
    A \term{queue} is a collection equipped with two operations.
    \begin{itemize}
        \item \term{enqueue} adds an element.
        \item \term{dequeue} reads and removes the first added element.
    \end{itemize}
    It is sometimes called a \term{FIFO} or \term{first-in-first-out} collection. 
\end{defi}
\begin{impl}[Array-Based Circular Queue]
    The idea of an \term{array-based circular queue} is that we can add two attributes that point to the beginning (head) and end (tail) of the queue, so we can implement Enqueue and Dequeue in $O(1)$ time. Additionally, we imagine the end of the array wraps around to the beginning, as to not cause overflows when we have space free at the beginning of the array. There are many possible implementations, here is one that does not handle overflow and underflow.
    \\ An array-based circular queue $Q$ will have 3 attributes: An array $Q$, of size $Q.length$, and positive integers $Q.head$ and $Q.tail$.\mypar
    \begin{algorithm}[H]
        \caption{Enqueue($Q, x$)}
        $Q[Q.tail] = x$\;
        $Q.tail = (Q.tail + 1)\%Q.length$\;
    \end{algorithm}
    \begin{algorithm}[H]
        \caption{Dequeue($Q$)}
        $x = Q[Q.head]$\;
        $Q.head = (Q.head + 1)\%Q.length$\;
        \Return $x$\;
    \end{algorithm}
    Recall, $x\%y$ is the remainder of $x$ when divided by $y$. In the case of queues, this means that if the head/tail is at the end of the array, and we wish to dequeue/enqueue, the new value wraps back to 0. An if-else-statement could have been used instead in both dequeue and enqueue.
    \mypar Below are diagrams illustrating the operation of queues.
    \begin{figure}[H]
        \caption{A diagram illustrating Array-Based Circular Queues}
        \centering
        \begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,line width = 1pt, draw, anchor=center}]
            \node (A) {Start};
            \node[below = 0.2cm of A] (QAText) {$Q$};
            \node[stack=7, below = 0cm of QAText] (QA) {
            \nodepart{four}d
            \nodepart{five}c
            \nodepart{six}b
            \nodepart{seven}a
            };
            \node[right = 0.5cm of QA.seven east] (QAHeadText) {$Q.head$};
            \draw[->,line width = 1pt] (QAHeadText.west) -- (QA.seven east);
            \node[right = 0.5cm of QA.three east] (QATailText) {$Q.tail$};
            \draw[->,line width = 1pt] (QATailText.west) -- (QA.three east);

            \node[right = 1.2cm of A] (B) {Enqueue($Q,x$)};
            \node[below = 0.2cm of B] (QBText) {$Q$};
            \node[stack=7, below = 0cm of QBText] (QB) {
            \nodepart{three}x
            \nodepart{four}d
            \nodepart{five}c
            \nodepart{six}b
            \nodepart{seven}a
            };
            \node[right = 0.5cm of QB.seven east] (QBHeadText) {$Q.head$};
            \draw[->,line width = 1pt] (QBHeadText.west) -- (QB.seven east);
            \node[right = 0.5cm of QB.two east] (QBTailText) {$Q.tail$};
            \draw[->,line width = 1pt] (QBTailText.west) -- (QB.two east);

            \node[right = 1.2cm of B] (C) {Dequeue($Q$)};
            \node[below = 0.2cm of C] (QCText) {$Q$};
            \node[stack=7, below = 0cm of QCText] (QC) {
            \nodepart{three}x
            \nodepart{four}d
            \nodepart{five}c
            \nodepart{six}b
            \nodepart{seven}{\color{lightgray} a}
            };
            \node[right = 0.5cm of QC.six east] (QCHeadText) {$Q.head$};
            \draw[->,line width = 1pt] (QCHeadText.west) -- (QC.six east);
            \node[right = 0.5cm of QC.two east] (QCTailText) {$Q.tail$};
            \draw[->,line width = 1pt] (QCTailText.west) -- (QC.two east);
            \node[below = 0.2cm of QC] (return) {return a};

        \end{tikzpicture}
    \end{figure}
    \begin{figure}[H]
        \caption{A diagram illustrating wrapping in Array-Based Circular Queues}
        \centering
        \begin{tikzpicture}[stack/.style={rectangle split, rectangle split parts=#1,draw, line width = 1pt, anchor=center}]
            \node (A) {\small Start};
            \node[below = 0.5cm of A.center] (QAText) {$Q$};
            \node[stack=7, below = 0cm of QAText] (QA) {
                \nodepart{two}f
                \nodepart{three}{\color{lightgray} e}
                \nodepart{four}{\color{lightgray} d}
                \nodepart{five}{\color{lightgray} c}
                \nodepart{six}{\color{lightgray} b}
                \nodepart{seven}{\color{lightgray} a}
            };
            \node[right = 0.3cm of QA.two east] (QAHeadText) {\small $Q.head$};
            \draw[->,line width = 1pt] (QAHeadText.west) -- (QA.two east);
            \node[right = 0.3cm of QA.one east] (QATailText) {\small $Q.tail$};
            \draw[->,line width = 1pt] (QATailText.west) -- (QA.one east);

            \node[right = 1.2cm of A.center] (B) {\small Enqueue($Q,g$)};
            \node[below = 0.5cm of B.center] (QBText) {$Q$};
            \node[stack=7, below = 0cm of QBText] (QB) {
                \nodepart{one}g
                \nodepart{two}f
                \nodepart{three}{\color{lightgray} e}
                \nodepart{four}{\color{lightgray} d}
                \nodepart{five}{\color{lightgray} c}
                \nodepart{six}{\color{lightgray} b}
                \nodepart{seven}{\color{lightgray} a}
            };
            \node[right = 0.3cm of QB.two east] (QBHeadText) {\small $Q.head$};
            \draw[->,line width = 1pt] (QBHeadText.west) -- (QB.two east);
            \node[right = 0.3cm of QB.seven east] (QBTailText) {\small $Q.tail$};
            \draw[->,line width = 1pt] (QBTailText.west) -- (QB.seven east);

            \node[right = 1.2cm of B.center] (C) {\small Enqueue($Q,h$)};
            \node[below = 0.5cm of C.center] (QCText) {$Q$};
            \node[stack=7, below = 0cm of QCText] (QC) {
                \nodepart{one}g
                \nodepart{two}f
                \nodepart{three}{\color{lightgray} e}
                \nodepart{four}{\color{lightgray} d}
                \nodepart{five}{\color{lightgray} c}
                \nodepart{six}{\color{lightgray} b}
                \nodepart{seven}h
            };
            \node[right = 0.3cm of QC.two east] (QCHeadText) {\small$Q.head$};
            \draw[->,line width = 1pt] (QCHeadText.west) -- (QC.two east);
            \node[right = 0.3cm of QC.six east] (QCTailText) {\small$Q.tail$};
            \draw[->,line width = 1pt] (QCTailText.west) -- (QC.six east); 
            
            \node[right = 1.2cm of C.center] (D) {\small Dequeue($Q$)};
            \node[below = 0.5cm of D.center] (QDText) {$Q$};
            \node[stack=7, below = 0cm of QDText] (QD) {
                \nodepart{one}g
                \nodepart{two}{\color{lightgray} f}
                \nodepart{three}{\color{lightgray} e}
                \nodepart{four}{\color{lightgray} d}
                \nodepart{five}{\color{lightgray} c}
                \nodepart{six}{\color{lightgray} b}
                \nodepart{seven}h
            };
            \node[right = 0.3cm of QD.one east] (QDHeadText) {\small$Q.head$};
            \draw[->,line width = 1pt] (QDHeadText.west) -- (QD.one east);
            \node[right = 0.3cm of QD.six east] (QDTailText) {\small$Q.tail$};
            \draw[->,line width = 1pt] (QDTailText.west) -- (QD.six east);
            \node[below = 0.2cm of QD] (return) {return f};

            \node[right = 1.2cm of D.center] (E) {\small Dequeue($Q$)};
            \node[below = 0.5cm of E.center] (QEText) {$Q$};
            \node[stack=7, below = 0cm of QEText] (QE) {
                \nodepart{one}{\color{lightgray} g}
                \nodepart{two}{\color{lightgray} f}
                \nodepart{three}{\color{lightgray} e}
                \nodepart{four}{\color{lightgray} d}
                \nodepart{five}{\color{lightgray} c}
                \nodepart{six}{\color{lightgray} b}
                \nodepart{seven}h
            };
            \node[right = 0.3cm of QE.seven east] (QEHeadText) {\small$Q.head$};
            \draw[->,line width = 1pt] (QEHeadText.west) -- (QE.seven east);
            \node[right = 0.3cm of QE.six east] (QETailText) {\small$Q.tail$};
            \draw[->,line width = 1pt] (QETailText.west) -- (QE.six east);
            \node[below = 0.2cm of QE] (return) {return g};

        \end{tikzpicture}
    \end{figure}
\end{impl}
\pagebreak
\begin{impl}[Array-Based Circular Queue with Error Handling]
    Our previous implementation did not handle overflow or underflow errors. One way of checking for overflow and underflow is to interpret $Q.head = Q.tail$ as "The queue is empty". This only allows us to store $Q.length - 1$ elements, as if, from empty, we attempt to enqueue $Q.length$ elements, we will return to having $Q.head = Q.tail$. \\ An array-based circular queue $Q$ will have 3 attributes: An array $Q$, of size $Q.length$, and positive integers $Q.head$ and $Q.tail$.\mypar
    \begin{algorithm}[H]
        \caption{Queue-Empty($Q$)}
        \uIf{$Q.head == Q.tail$}{\Return True\;}
        \Else{\Return False\;}
    \end{algorithm}
    \begin{algorithm}[H]
        \caption{Queue-Full($Q$)}
        \uIf{$Q.head == (Q.tail + 1)\% Q.length$}{\Return True\;}
        \Else{\Return False\;}
    \end{algorithm}
    \begin{algorithm}[H]
        \caption{Enqueue($Q, x$)}
        $Q[Q.tail] = x$\;
        \uIf{Queue-Full($Q$)}
        {
            \Error Overflow\;
        } 
        \Else
        {
            $Q.tail = (Q.tail + 1)\%Q.length$\;
        }
    \end{algorithm}
    \begin{algorithm}[H]
        \caption{Dequeue($Q$)}
        $x = Q[Q.head]$\;
        \uIf{Queue-Empty($Q$)}
        {
            \Error Underflow\;
            
        }
        \Else
        {
            $Q.head = (Q.head + 1)\%Q.length$\;
        }
        \Return $x$\;
    \end{algorithm}
\end{impl}
\section{Linked Lists}
Here we define a data structure called a \term{linked list}, which allows for the storage of arbitrarily many elements.
\begin{defi}
    [Singly Linked List]
    In a \term{singly linked list}, there is a distinguished element called the head, and each element is stored alongside a pointer to the next element. There is also an element called the tail, whose next pointer points to NIL.
\end{defi}
\begin{figure}[H]
    \caption{A singly linked list $L$ representing the list $(19,2,5,101,3)$}
    \centering
    \begin{tikzpicture}[cell/.style={rectangle split, rectangle split horizontal , rectangle split parts=2, line width = 1pt, draw}]
        \node[cell] (cell1) 
        {
            \nodepart{one}{19}
        };
        \node[cell, right = of cell1] (cell2) 
        {
            \nodepart{one}{2}
        };
        \node[cell, right = of cell2] (cell3) 
        {
            \nodepart{one}{5}
        };
        \node[cell, right = of cell3] (cell4) 
        {
            \nodepart{one}{101}
        };
        \node[cell, right = of cell4] (cell5) 
        {
            \nodepart{one}{3}
            \nodepart{two}{$\bullet$}
        };
        \node[below = .5cm of cell1] (headtext) {$L.head$};
%        \node[below = .5cm of cell5] (tailtext) {$L.tail$};
        \node[above = 0.7cm of cell1.one north,anchor=center] (keytext) {\small $key$};
        \node[above right = 1cm of cell1.two north,anchor=center] (nexttext) {\small $next$};
        \draw[->,line width = 1pt] (cell1.two east) -- (cell2.one west);
        \draw[->,line width = 1pt] (cell2.two east) -- (cell3.one west);
        \draw[->,line width = 1pt] (cell3.two east) -- (cell4.one west);
        \draw[->,line width = 1pt] (cell4.two east) -- (cell5.one west);
        \draw[->,line width = 1pt] (headtext.north) -- (cell1.south);
%        \draw[->,line width = 1pt] (tailtext.north) -- (cell5.south);
        \draw[->,line width = 1pt] (keytext.south) -- (cell1.one north);
        \draw[->,line width = 1pt] (nexttext.south west) -- (cell1.two north);
    \end{tikzpicture}
\end{figure}
\begin{defi}
    [Doubly Linked List]
    In a \term{doubly linked list}, there is a distinguished element called the head, and each element is stored alongside pointers to the next and previous elements. The prev pointer of the head will point to NIL, and there is an element called the tail, whose next pointer points to NIL.
\end{defi}
\begin{figure}[H]
    \caption{A doubly linked list $L$ representing the list $(12,5,541,0)$}
    \centering
    \begin{tikzpicture}[cell/.style={rectangle split, rectangle split horizontal , rectangle split parts=3,line width = 1pt, draw}]
        \node[cell] (cell1) 
        {
            \nodepart{one}{$\bullet$}
            \nodepart{two}{12}
        };
        \node[cell, right = of cell1] (cell2) 
        {
            \nodepart{two}{5}
        };
        \node[cell, right = of cell2] (cell3) 
        {
            \nodepart{two}{541}
        };
        \node[cell, right = of cell3] (cell4) 
        {
            \nodepart{two}{0}
            \nodepart{three}{$\bullet$}
        };
        \node[below = .5cm of cell1] (headtext) {$L.head$};
        % \node[below = .5cm of cell4] (tailtext) {$L.tail$};
        \node[above = 0.33cm of cell1.two north,anchor=south] (keytext) {\small $key$};
        \node[above left = .5cm of cell1.one north,anchor=south east] (prevtext) {\small $prev$};
        \node[above right = .5cm of cell1.three north,anchor=south west] (nexttext) {\small $next$};
        \draw[->,line width = 1pt] ($(cell1.south east)!.7!(cell1.north east)$) -- ($(cell2.south west)!.7!(cell2.north west)$);
        \draw[->,line width = 1pt] ($(cell2.south east)!.7!(cell2.north east)$) -- ($(cell3.south west)!.7!(cell3.north west)$);
        \draw[->,line width = 1pt] ($(cell3.south east)!.7!(cell3.north east)$) -- ($(cell4.south west)!.7!(cell4.north west)$);
        \draw[->,line width = 1pt] ($(cell2.south west)!.3!(cell2.north west)$) -- ($(cell1.south east)!.3!(cell1.north east)$);
        \draw[->,line width = 1pt] ($(cell3.south west)!.3!(cell3.north west)$) -- ($(cell2.south east)!.3!(cell2.north east)$);
        \draw[->,line width = 1pt] ($(cell4.south west)!.3!(cell4.north west)$) -- ($(cell3.south east)!.3!(cell3.north east)$);

        \draw[->,line width = 1pt] (headtext.north) -- (cell1.south);
        % \draw[->,line width = 1pt] (tailtext.north) -- (cell4.south);
        \draw[->,line width = 1pt] (keytext.south) -- (cell1.two north);
        \draw[->,line width = 1pt] (prevtext.south east) -- (cell1.one north);
        \draw[->,line width = 1pt] (nexttext.south west) -- (cell1.three north);
    \end{tikzpicture}
\end{figure}
\begin{defi}
    [Contiguous Data Structure]
    We say that a data structure is \term{contiguous} if it stores all its data together in memory.
\end{defi}
\begin{eg}
    An array is a contiguous data structure.
\end{eg}
\begin{noneg}
    A linked list is \textbf{not} a contiguous data structure.
\end{noneg}
\pagebreak
\subsection{Operations on Linked Lists}
\subsubsection{Searching for a key in a linked list}
We wish to search a linked list, $L$, for a key, $k$, return a pointer to the element of the list if found, otherwise return $NIL$. \mypar
\begin{algorithm}
    [H]
    \caption{List-Search($L,k$)}
    $x = L.head$\;
    \While {$x \not= NIL$ and $x.key \not= k$}
    {$x = x.next$\;}
    \textbf{return }$x$\;
\end{algorithm}
\mypar
List-Search has worst case time complexity $\Theta(n)$, in the case the entire list has to be searched, and best case $\Theta(1)$, in the case that the first element has key $k$.
\subsubsection{Inserting an element}
When inserting an element, it is appended to the front of the list, and becomes the new head. \\ Given a list $L$ and pointer $x$ to a new list element with a set key, we append $x$ to $L$ as follows.
\mypar
\begin{algorithm}
    [H]
    \caption{List-Insert($L,x$)}
    $x.next = L.head$\;
    \If{$L.head \not= NIL$}
    {$L.head.prev = x$\;}
    $L.head = x$\;
    $x.prev = NIL$\;
\end{algorithm} \mypar
The running time of List-Insert is $O(1)$.
\pagebreak
\subsubsection{Deleting an element}
Given an element $x$ of a linked list $L$, we wish to delete $x$ from $L$.
\mypar
\begin{algorithm}
    [H]
    \caption{List-Delete($L,x$)}
    \uIf{$x.prev \not= NIL$}
    {$x.prev.next = x.next$\;}
    \Else 
    {$L.head = x.next$\;}
    \If{$x.next \not= NIL$}
    {$x.next.prev = x.prev$\;}
\end{algorithm}
\mypar
The running time of List-Delete is $O(1)$.
\subsection{Dealing with the Boundary Conditions}
\subsubsection{Circular Linked Lists}
A circular linked list, intuitively, loops to and from the beginning and end.
\begin{defi}
    [Circular Linked List] A singly linked list is circular if the next pointer of the tail points to the head.\\ A doubly linked list is circular if the prev pointer of the head points to the tail, and the next pointer of the tail points to the head. 
\end{defi}
\begin{figure}[H]
    \caption{A circular doubly linked list $L$ representing the list $(12,5,541,0)$}
    \centering
    \begin{tikzpicture}[cell/.style={rectangle split, rectangle split horizontal , rectangle split parts=3, line width = 1pt,draw}]
        \node[cell] (cell1) 
        {
            \nodepart{one}{}
            \nodepart{two}{12}
        };
        \node[cell, right = of cell1] (cell2) 
        {
            \nodepart{two}{5}
        };
        \node[cell, right = of cell2] (cell3) 
        {
            \nodepart{two}{541}
        };
        \node[cell, right = of cell3] (cell4) 
        {
            \nodepart{two}{0}
            \nodepart{three}{}
        };
        \node[left = .5cm of cell1] (headtext) {$L.head$};

        \node[above = .25cm of cell1.one north] (headPrev1) {};
        \node[above = .25cm of cell4.two north] (headPrev2) {};
        \node[below = .25cm of cell4.three south] (tailNext1) {};
        \node[below = .25cm of cell1.two south] (tailNext2) {};


        \draw[->,line width = 1pt] ($(cell1.south east)!.7!(cell1.north east)$) -- ($(cell2.south west)!.7!(cell2.north west)$);
        \draw[->,line width = 1pt] ($(cell2.south east)!.7!(cell2.north east)$) -- ($(cell3.south west)!.7!(cell3.north west)$);
        \draw[->,line width = 1pt] ($(cell3.south east)!.7!(cell3.north east)$) -- ($(cell4.south west)!.7!(cell4.north west)$);
        \draw[->,line width = 1pt] ($(cell2.south west)!.3!(cell2.north west)$) -- ($(cell1.south east)!.3!(cell1.north east)$);
        \draw[->,line width = 1pt] ($(cell3.south west)!.3!(cell3.north west)$) -- ($(cell2.south east)!.3!(cell2.north east)$);
        \draw[->,line width = 1pt] ($(cell4.south west)!.3!(cell4.north west)$) -- ($(cell3.south east)!.3!(cell3.north east)$);

        \draw[->,line width = 1pt] (headtext.east) -- (cell1.west);
        \draw[->,line width = 1pt] (cell1.one north) -- (headPrev1.center)  -- (headPrev2.center)  -- (cell4.two north);
        \draw[->,line width = 1pt] (cell4.three south) -- (tailNext1.center)  -- (tailNext2.center)  -- (cell1.two south);
    \end{tikzpicture}
\end{figure}
\subsubsection{Sentinels}
Notice that in List-Delete and List-Insert, we have to check for the boundary conditions, it would be nice if this wasn't necessary. A \term{sentinel} is a dummy object designed to simplify the boundary conditions of a doubly linked list. The idea is that the sentinel will represent NIL, but will additionally have a next and prev pointer, pointing to the head and tail respectively.
\begin{figure}[H]
    \caption{A circular doubly linked list with a sentinel, $L$, representing the list $(15,1,11)$}
    \centering
    \begin{tikzpicture}[cell/.style={rectangle split, rectangle split horizontal , rectangle split parts=3, line width = 1pt,draw}]
        \node[cell,fill=mygray] (cell1) 
        {
            \nodepart{one}{}
            \nodepart{two}{}
        };
        \node[cell, right = of cell1] (cell2) 
        {
            \nodepart{two}{15}
        };
        \node[cell, right = of cell2] (cell3) 
        {
            \nodepart{two}{1}
        };
        \node[cell, right = of cell3] (cell4) 
        {
            \nodepart{two}{11}
            \nodepart{three}{}
        };
        \node[left = .5cm of cell1] (niltext) {$L.nil$};

        \node[above = .25cm of cell1.one north] (headPrev1) {};
        \node[above = .25cm of cell4.two north] (headPrev2) {};
        \node[below = .25cm of cell4.three south] (tailNext1) {};
        \node[below = .25cm of cell1.two south] (tailNext2) {};


        \draw[->,line width = 1pt] ($(cell1.south east)!.7!(cell1.north east)$) -- ($(cell2.south west)!.7!(cell2.north west)$);
        \draw[->,line width = 1pt] ($(cell2.south east)!.7!(cell2.north east)$) -- ($(cell3.south west)!.7!(cell3.north west)$);
        \draw[->,line width = 1pt] ($(cell3.south east)!.7!(cell3.north east)$) -- ($(cell4.south west)!.7!(cell4.north west)$);
        \draw[->,line width = 1pt] ($(cell2.south west)!.3!(cell2.north west)$) -- ($(cell1.south east)!.3!(cell1.north east)$);
        \draw[->,line width = 1pt] ($(cell3.south west)!.3!(cell3.north west)$) -- ($(cell2.south east)!.3!(cell2.north east)$);
        \draw[->,line width = 1pt] ($(cell4.south west)!.3!(cell4.north west)$) -- ($(cell3.south east)!.3!(cell3.north east)$);

        \draw[->,line width = 1pt] (niltext.east) -- (cell1.west);
        \draw[->,line width = 1pt] (cell1.one north) -- (headPrev1.center)  -- (headPrev2.center)  -- (cell4.two north);
        \draw[->,line width = 1pt] (cell4.three south) -- (tailNext1.center)  -- (tailNext2.center)  -- (cell1.two south);
    \end{tikzpicture}
\end{figure}
This simplifies the code for deleting and inserting elements.
\mypar
\begin{algorithm}
    [H]
    \caption{List-Delete-Sentinel($L,x$)}
    $x.prev.next = x.next$\;
    $x.next.prev = x.prev$\;
\end{algorithm}
\mypar
\begin{algorithm}
    [H]
    \caption{List-Insert-Sentinel($L,x$)}
    $x.next = L.nil.next$\;
    $L.nil.next.prev = x$\;
    $L.nil.next = x$\;
    $x.prev = L.nil$\;
\end{algorithm} 
\mypar
The code for search barely changes at all.
\mypar
\begin{algorithm}
    [H]
    \caption{List-Search-Sentinel($L,k$)}
    $x = L.nil.next$\;
    \While {$x \not= L.nil$ and $x.key \not= k$}
    {$x = x.next$\;}
    \textbf{return }$x$\;
\end{algorithm}
\mypar
Sentinels save $O(1)$ time per insert or delete operation, however cost $O(1)$ extra space. Hence they are useful when there is a need for a small number of long lists, but may be detrimental when using a large number of small lists.
\pagebreak
\section{The Sorting Problem}
\begin{nproblem}[The Comparison Sorting Problem]
    The \term{comparison sorting problem} refers to the task of sorting a sequence of values into ascending order.
    \mypar \textbf{Input:} A sequence $(a_1, \dots, a_n)$ of values of a type equipped with a total order relation $\leq$.
    \mypar \textbf{Output:} A permutation $(a'_1, \dots, a'_n)$ of $(a_1, \dots, a_n)$ such that 
    \[\forall i,j \in \{1,\dots,n \}, \ \  i \leq j \implies a'_i \leq a'_j  \]
    i.e. a permutation in (monotone) ascending order.
\end{nproblem}

\printindex
\end{document}